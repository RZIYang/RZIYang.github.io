<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Problem#25 题解]]></title>
    <url>%2Ff8145b0b%2F</url>
    <content type="text"><![CDATA[题目传送门 题意：给定一个链表和一个整数 k ，让链表每隔 k 个节点就反转一次，如果剩下的节点个数不足 k 个，就不进行反转，将反转后的链表首部返回。 思路：这题和之前的反转相邻两个节点的区别就是，这题的反转的节点的个数是不确定的。这里因为反转之后的节点有可能无法通过链表的 next 访问到或者通过 next 访问的步骤太复杂了，所以我想法是用一个 ListNode 指针数组来存储链表的所有节点，然后再进行访问并反转就比较简单了。假设某链表有 n 组 k 个节点，这里将这 n 组节点分为两部分来考虑，第一部分是前 n - 1 组节点，第二部分是第 n 组节点，前面的 n - 1 组节点都是同样的思路。 这里用 head = [1, 2, 3, 4, 5, 6, 7, 8] k = 3 来举例，对于前面 n - 1 组，即 head[1] 、 head[2] 和 head[3] （这里用 head[n] 代表链表的第 n 个节点），我的思路如下： 123head[1]-&gt;next = head[6]; // 这里将 head[1] 和下一组反转后的第一个节点（即 head[6]）连接起来head[2]-&gt;next = head[1]; // 接下来就是将剩下的节点与它的前一个节点连接起来就够了head[3]-&gt;next = head[2]; 对于第 n 组，即 head[4] 、 head[5] 和 head[6] ，则基本上相同，只有第一个节点不同： 123head[4]-&gt;next = head[7]; // 这里由于后面剩下的节点不足 3 个，所以剩下的节点不需要进行反转，需要注意的是：如果剩下的节点数正好为 0，那么就需要特判，将 head[4] 的 next 设置为 nullptr,不然可能会数组访问越界造成 Runtime Errorhead[5]-&gt;next = head[4];head[6]-&gt;next = head[5]; 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution&#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; ListNode *arr[5001]; int arrSize = 0; ListNode *p = head; while (p != nullptr) &#123; arr[arrSize] = p; arrSize++; p = p-&gt;next; &#125; ListNode *res = nullptr; res = arr[k - 1]; for (int i = 0; i &lt; (arrSize / k) * k; i++) &#123; if (i % k == 0) &#123; if (i / k != arrSize / k - 1) &#123; arr[i]-&gt;next = arr[i + 2 * k - 1]; &#125; else &#123; if (i + k &lt; arrSize) &#123; arr[i]-&gt;next = arr[i + k]; &#125; else &#123; arr[i]-&gt;next = nullptr; &#125; &#125; &#125; else &#123; arr[i]-&gt;next = arr[i - 1]; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem#24 题解]]></title>
    <url>%2F34be5b95%2F</url>
    <content type="text"><![CDATA[题目传送门 题意：给定一个链表，交换链表中相邻的两个节点，返回头节点。 思路：有两种方法，一种是将相邻两个节点的值交换。一种是不修改值，仅修改节点的 next 值。显然，第一种较为简单，第二种较难。这里我用的是第二种。首先，将链表分为两部分进行处理，一部分是头部的两个节点，另一部分是链表的其他节点。这里为了表述方便，我用 head[1] 代表链表的头节点， head[2] 代表第二个节点，以此类推， head[n] 代表第 n 个节点。 对头部两个节点的处理，就是直接经过以下处理就可以了： 1234ListNode* tmp = head[2];head[1]-&gt;next = head[1]-&gt;next-&gt;next;tmp-&gt;next = head[1]; // 这里由于 head[1] 的 next 变了，无法直接访问到 head[2] ，需要提前将 head[2] 存到一个临时指针变量中res = tmp; // res 为新的头节点，用于将结果返回 对于其他部分的节点，这里为了方便，我用 head[3] 和 head[4] 的交换来进行举例。 12345ListNode* p = head[2]; // 这里将 head[2] 存起来是为了通过 head[2] 来访问 head[3] 和 head[4]，之所以不直接用 head[3]，是因为如果用 head[3] 就无法将交换之后的 head[4] 和之前的 head[2] 连接起来ListNode* tmp = head[4]; // 将 head[5] 存储起来，原因类似于上面的 head[2]p-&gt;next-&gt;next = p-&gt;next-&gt;next-&gt;next; // 等同于 head[3]-&gt;next = head[5]tmp-&gt;next = p-&gt;next; // 等同于 head[4]-&gt;next = head[3]p-&gt;next = tmp; //等同于 head[2]-&gt;next = head[4] 上面就是大致的思路了。接下来是 AC 的代码： 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution&#123;public: ListNode *swapPairs(ListNode *head) &#123; ListNode *res = nullptr; if (head != nullptr) &#123; res = head; if (head-&gt;next != nullptr) &#123; ListNode *t = head-&gt;next; head-&gt;next = head-&gt;next-&gt;next; t-&gt;next = head; res = t; head = t-&gt;next; &#125; &#125; while (head != nullptr &amp;&amp; head-&gt;next != nullptr &amp;&amp; head-&gt;next-&gt;next != nullptr) &#123; ListNode *t = head-&gt;next-&gt;next; head-&gt;next-&gt;next = head-&gt;next-&gt;next-&gt;next; t-&gt;next = head-&gt;next; head-&gt;next = t; head = t-&gt;next; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem#15 题解]]></title>
    <url>%2Fc19967ce%2F</url>
    <content type="text"><![CDATA[题目传送 题目概述：给出一个数组，在该数组中寻找若干组三个数字相加和为 0 的组合，且这三个数字不能全部相同。 思路：由输出样例可以看出，结果是由小到大排序了的，且没有重复的组合。所以我一开始的思路是将数组进行排序。然后去重，将三个或以上的重复数字删减为两个。最后再通过固定一个数字，采用双指针法得出结果。最终由于花了太长时间没有将代码实现出来，我就看了 Discuss 里面别人的解题思路，发现别人没有去重的操作，而是通过在双指针法得出 nums[i] + nums[left] + nums[right] == 0 之后，判断 left 的右边的数字是否和 left 的数字相同来达到去重的效果， right 同理。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution&#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; &amp;nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; // 由于输出结果排好了序，所以需要进行排序 sort(nums.begin(), nums.end()); int vecSize = nums.size(); // 接下来将一个值固定，然后对其它值使用双指针法判断 for (int i = 0; i &lt; vecSize - 2; i++) &#123; // 判断固定的数字是否重复，如果重复就直接跳过 if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int left = i + 1; int right = vecSize - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; vector&lt;int&gt; t = &#123;nums[i], nums[left], nums[right]&#125;; res.push_back(t); // 这里对 left 后面的数字进行去重 while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; // 这里对 right 前面的数字进行去重 while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; left++; right--; &#125; else if (sum &lt; 0) &#123; left++; &#125; else if (sum &gt; 0) &#123; right--; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Java]基于k-means算法的图像分割]]></title>
    <url>%2F25e42248%2F</url>
    <content type="text"><![CDATA[文章的开头先介绍一下 k-means 算法： 输入： ​ k：簇的数目 ​ D：包含n个对象的数据集。 输出： k个簇的集合 步骤： ​ （1）从D中任意选择k个对象最为初始簇中心。 ​ （2）根据簇中对象的均值，将每个对象分配到最相似的簇。 ​ （3）更新簇均值，即重新计算每个簇中对象的均值。 ​ （4）重复步骤（2）和步骤（3）直到簇均值不再变化。 ​ 我这里使用的是基于聚类的图像分割，k-means算法是进行基于聚类的图像分割的经典算法，这个算法有在使用时有一些缺陷： ​ （1）结果容易被初始簇中心的选择所影响，容易陷入局部最优。 ​ （2）聚类的效果非常依赖于k值的选择。k值过小，分割效果不明显。k值过大，图像的细节会过于明显。 ​ 由于能力有限，我写的k-means算法的优化的方面主要有两个： ​ （1）初始簇中心的选择，通过将图片像素灰度化（将RGB值按3:6:1计算得出），按照灰度值排序，然后将数据集k等分，取每个等分的平均值（灰度值）作为簇类中心的值（灰度值，R=G=B=灰度值）。 ​ （2）使用拐点法和平均轮廓系数法，根据程序运行输出的误差平方和（SSE）和平均轮廓系数，绘制折线图，然后根据折线图确认k值。 代码： dataItem.java 12345678910111213141516171819202122232425package com.bigData;public class dataItem &#123; public int r; public int g; public int b; public int grayScale; public int group;&#125;class sortDataItem implements Comparable&lt;sortDataItem&gt; &#123; public dataItem di; public int width; public int height; public sortDataItem() &#123; di = new dataItem(); &#125; @Override public int compareTo(sortDataItem s) &#123; if (this.di.grayScale != s.di.grayScale) return this.di.grayScale &lt; s.di.grayScale ? 1 : -1; return 0; &#125;&#125; ImageCluster.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330package com.bigData;import java.awt.Color;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.util.Arrays;import javax.imageio.ImageIO;public class ImageCluster &#123; //主要功能就是读取一副图像，再对图像进行分割 //需要分类的簇数 private int k; //迭代次数 //private int m; //数据集合 private dataItem[][] source; //簇类中心集合 private dataItem[] center; //统计每个簇的像素点的总和，用于计算新的簇类中心 private dataItem[] centerSum; // 图片的宽高 private int width; private int height; private void init() &#123; center = null; centerSum = null; &#125; //读取指定目录的图片数据，并且写入数组，这个数据要继续处理 private int[][] getImageData(String path) &#123; BufferedImage bi = null; try &#123; bi = ImageIO.read(new File(path)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; width = bi.getWidth(); height = bi.getHeight(); int[][] data = new int[width][height]; for (int i = 0; i &lt; width; i++) for (int j = 0; j &lt; height; j++) data[i][j] = bi.getRGB(i, j); return data; &#125; //用来得到灰度值，使用加权平均法，rgb取3:6:1 private int getGrayScale(int r, int g, int b) &#123; return (r * 3 + g * 6 + b) / 10; &#125; //用来处理获取的像素数据，将整型数组的值转化为RGB值，存储进dataItem类型的二维数组中，返回二维数组 private dataItem[][] InitData(int[][] data) &#123; dataItem[][] dataitems = new dataItem[data.length][data[0].length]; for (int i = 0; i &lt; data.length; i++) &#123; for (int j = 0; j &lt; data[0].length; j++) &#123; dataItem di = new dataItem(); Color c = new Color(data[i][j]); di.r = c.getRed(); di.g = c.getGreen(); di.b = c.getBlue(); di.grayScale = getGrayScale(di.r, di.g, di.b); di.group = 1; dataitems[i][j] = di; &#125; &#125; return dataitems; &#125; //将排好序的数据k等分然后返回各个等分的平均数 public int getAverage(sortDataItem[] s, int t) &#123; int begin = s.length / k * t; int end = s.length / k * (t + 1); int sum = 0; for (int i = begin; i &lt; end; i++) &#123; sum += s[i].di.grayScale; &#125; return sum / (s.length / k); &#125; //生成初始中心,初始化中心通过将像素点按照灰度值排序，然后k等分，在等分后的各个部分中取像素的平均数作为每个聚类初始中心 private void initCenters(int k) &#123; center = new dataItem[k]; centerSum = new dataItem[k];//用来统计每个聚类里面的RGB分别之和，方便计算均值 //初始化sortDI sortDataItem[] sortDI = new sortDataItem[width * height]; for (int i = 0; i &lt; sortDI.length; i++) &#123; sortDI[i] = new sortDataItem(); &#125; //将数据存储进sortDI中 for (int i = 0; i &lt; width; i++) &#123; for (int j = 0; j &lt; height; j++) &#123; sortDI[i * height + j].di = source[i][j]; sortDI[i * height + j].width = i; sortDI[i * height + j].height = j; &#125; &#125; //排序 Arrays.sort(sortDI, sortDataItem::compareTo); for (int i = 0; i &lt; k; i++) &#123; dataItem cent = new dataItem(); dataItem cent2 = new dataItem(); cent.group = i; int gs = getAverage(sortDI, i); cent.r = gs; cent.g = gs; cent.b = gs; cent.grayScale = gs; center[i] = cent; cent2.r = 0; cent2.g = 0; cent2.b = 0; cent2.grayScale = 0; cent2.group = 0; centerSum[i] = cent2; &#125; &#125; //计算两个像素之间的RGB的欧几里得距离 private double distance(dataItem first, dataItem second) &#123; return Math.sqrt((first.r - second.r) * (first.r - second.r) + (first.g - second.g) * (first.g - second.g) + (first.b - second.b) * (first.b - second.b)); &#125; //返回一个数组中最小的坐标 private int minDistance(double[] distance) &#123; double minDistance = distance[0]; int minLocation = 0; for (int i = 0; i &lt; distance.length; i++) &#123; if (distance[i] &lt; minDistance) &#123; minDistance = distance[i]; minLocation = i; &#125; else if (distance[i] == minDistance) &#123; if ((Math.random() * 10) &lt; 5) &#123; minLocation = i; &#125; &#125; &#125; return minLocation; &#125; // 每个点进行分类 private void clusterSet() &#123; int group = -1; double distance[] = new double[k]; for (int i = 0; i &lt; width; i++) &#123; for (int j = 0; j &lt; height; j++) &#123; //求出距离中心点最短的中心 for (int q = 0; q &lt; k; q++) &#123; distance[q] = distance(center[q], source[i][j]); &#125; group = minDistance(distance);//寻找该点最近的中心 source[i][j].group = group;//把该点进行分类 centerSum[group].r += source[i][j].r; centerSum[group].g += source[i][j].g; centerSum[group].b += source[i][j].b; //centerSum[group].grayScale += source[i][j].grayScale; centerSum[group].group += 1;//这个就是用来统计聚类里有几个点 group = -1; &#125; &#125; &#125; //设置新的中心 public void setNewCenter() &#123; for (int i = 0; i &lt; k; i++) &#123; //取平均值为新的中心 center[i].r = (int) (centerSum[i].r / centerSum[i].group); center[i].g = (int) (centerSum[i].g / centerSum[i].group); center[i].b = (int) (centerSum[i].b / centerSum[i].group); center[i].grayScale = getGrayScale(center[i].r, center[i].g, center[i].b); center[i].group = i; &#125; &#125; //输出聚类好的数据 private void ImagedataOut(String path) &#123; Color[] c = new Color[k]; for (int i = 0; i &lt; k; i++) &#123; c[i] = new Color((i + 1) * (255 / (k + 1)), (i + 1) * (255 / (k + 1)), (i + 1) * (255 / (k + 1))); &#125; BufferedImage nbi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for (int i = 0; i &lt; width; i++) &#123; for (int j = 0; j &lt; height; j++) &#123; nbi.setRGB(i, j, c[source[i][j].group].getRGB()); &#125; &#125; try &#123; ImageIO.write(nbi, "jpg", new File(path)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //进行kmeans计算的核心函数 public void kmeans(String inPath, int maxK, int maxM) &#123; source = InitData(getImageData(inPath)); String outPath = "images\\out"; for (int t = 2; t &lt;= maxK; t++) &#123; init(); k = t; //初始化聚类中心 initCenters(k); //进行最多maxM次聚类 int m; for (m = 0; m &lt; maxM; m++) &#123; // 将每个点进行分类 clusterSet(); // 临时存储簇类中心的灰度值，用于后续判断灰度值是否改变 int[] oldCenter = new int[k]; for (int i = 0; i &lt; k; i++) &#123; oldCenter[i] = center[i].grayScale; &#125; // 设置新的簇类中心 setNewCenter(); // 判断旧的簇类中心和新的簇类中心是否相等，如果相等，说明再进行迭代就没有效果了 boolean flag = true; for (int i = 0; i &lt; k; i++) &#123; if (oldCenter[i] != center[i].grayScale) &#123; flag = false; break; &#125; &#125; if (flag == true) &#123; break; &#125; //重置之前的求和结果 for (int i = 0; i &lt; k; i++) &#123; centerSum[i].r = 0; centerSum[i].g = 0; centerSum[i].b = 0; centerSum[i].grayScale = 0; centerSum[i].group = 0; &#125; &#125; //当k值不同时输出不同的误差平方和，然后使用肘部法则判断取哪个k值 double SSE = 0; SSE = computeSSE(); //计算平均轮廓系数 double avgSC = 0; avgSC = computeAverageSilhouetteCoefficient(); //输出不同k值对应的迭代次数、误差平方和、平均轮廓系数 System.out.println("k = " + k + ", 迭代总次数：" + m + ", 误差平方和（除以像素总数）：" + String.format("%.2f", SSE / (width * height)) + ", 平均轮廓系数：" + String.format("%.2f", avgSC) ); //当k值不同时，输出不同k值对应的图片 ImagedataOut(outPath + k + ".jpg"); &#125; &#125; // 计算误差平方和（SSE） private double computeSSE() &#123; double SSE = 0; for (int i = 0; i &lt; width; i++) &#123; for (int j = 0; j &lt; height; j++) &#123; double dis = distance(source[i][j], center[source[i][j].group]); SSE += dis * dis; &#125; &#125; return SSE; &#125; // 计算轮廓系数 private double computeSilhouetteCoefficient(dataItem di, int x, int y) &#123; //计算di这个点的ao值 double ao = 0; //计算di这个点的bo值 double bo = 0; double[] dis = new double[k]; for (int i = 0; i &lt; width; i++) &#123; for (int j = 0; j &lt; height; j++) &#123; if (i != x &amp;&amp; i != y) &#123; if (source[i][j].group == di.group) &#123; ao += distance(di, source[i][j]); &#125; if (source[i][j].group != di.group) &#123; dis[source[i][j].group] += distance(di, source[i][j]); &#125; &#125; &#125; &#125; ao /= centerSum[di.group].group - 1; /* for (int i = 0; i &lt; width; i++) &#123; for (int j = 0; j &lt; height; j++) &#123; if (source[i][j].group != di.group) &#123; dis[source[i][j].group] += distance(di, source[i][j]); &#125; &#125; &#125; */ bo = Double.MAX_VALUE; for (int i = 0; i &lt; k; i++) &#123; if (i != di.group) &#123; dis[i] /= centerSum[i].group; if (bo &gt; dis[i]) &#123; bo = dis[i]; &#125; &#125; &#125; return (bo - ao) / (Math.max(ao, bo)); &#125; //计算平均轮廓系数 private double computeAverageSilhouetteCoefficient() &#123; double sum = 0; for (int i = 0; i &lt; width; i++) &#123; for (int j = 0; j &lt; height; j++) &#123; sum += computeSilhouetteCoefficient(source[i][j], i, j); &#125; &#125; return sum /= (width * height); &#125;&#125; Main.java 1234567891011package com.bigData;public class Main &#123; public static void main(String[] args) &#123; String inPath = "images\\in.jpg"; ImageCluster ic = new ImageCluster(); ic.kmeans(inPath, 16,200); &#125;&#125; 参考链接： 【Java】K-means算法Java实现以及图像分割（续）]]></content>
      <categories>
        <category>Java编程</category>
      </categories>
      <tags>
        <tag>图像分割</tag>
        <tag>数据挖掘</tag>
        <tag>k-means</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem#6 题解]]></title>
    <url>%2F6a1c6ea9%2F</url>
    <content type="text"><![CDATA[题目传送 题意：给出一个字符串 s 和数字 numRows ，当字符串 s 按照锯齿形状排列时，从左到右，从上到下将字符连接起来，然后返回这个新的字符串。numRows 为字符的行数。 样例： 123456Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;P A H NA P L S I I GY I R 思路一（WA）： 12345678910111213141516171819202122232425262728293031323334class Solution&#123;public: string convert(string s, int numRows) &#123; if(numRows == 1) return s; string res = ""; const int slen = s.length(); vector&lt;int&gt; vec; for(int i = 0; i * (numRows - 1) * 2 &lt; slen; i++) &#123; vec.push_back(i * (numRows - 1) * 2); &#125; const vector&lt;int&gt;::iterator itEnd = vec.end(); for(vector&lt;int&gt;::iterator it = vec.begin(); it != itEnd; ++it) &#123; res += s[*it]; &#125; int lenVec = vec.size(); for(int i = 1; i &lt; numRows - 1; i++) &#123; for(int j = 0; j &lt; lenVec; j++) &#123; if(vec[j] - i &gt;= 0) &#123; res += s[vec[j] - i]; &#125; if(vec[j] + i &lt; slen) &#123; res += s[vec[j] + i]; &#125; &#125; &#125; for(vector&lt;int&gt;::iterator it = vec.begin(); it != itEnd; ++it) &#123; if((*it) + numRows - 1 &lt; slen)res += s[(*it) + numRows - 1]; &#125; return res; &#125;&#125;; 我的思路是将锯齿状的字符划分为：第一行、最后一行和其他行这三个部分。第一行字符的下标的规律是 i*(numRows-1)*2 (i &gt;= 0) ，而其他行字符的下标可以通过第一行字符下标加一个整数或减一个整数得到，最后一行的下标可以通过第一行字符的下标加 numRows - 1​ 得到。但是这样会有特例过不了， 没过的样例是： 123456&quot;ABCD&quot;3AB DC 由于 vec 里面只有下标 0，所以没办法通过减一或加一访问到字符 D，所以就得到 &quot;ABC&quot; 的错误输出。我改进的想法有两个，一个是原有代码的基础上，在 vec 里面多加一个超过字符串长度的下标。然后在给 res 添加字符的时候判断下标是否在 s.length() 的范围内，二是只通过第一行下标加某两个特定数得到两个同一行的字符的下标，而不是原来的一加一减。然后我选择了第二个，因为需要改的地方较少。 思路二（AC）： 12345678910111213141516171819202122232425262728293031323334353637class Solution&#123;public: string convert(string s, int numRows) &#123; if(numRows == 1) return s; string res = ""; const int slen = s.length(); vector&lt;int&gt; vec; for(int i = 0; i * (numRows - 1) * 2 &lt; slen; i++) &#123; vec.push_back(i * (numRows - 1) * 2); &#125; const vector&lt;int&gt;::iterator itEnd = vec.end(); for(vector&lt;int&gt;::iterator it = vec.begin(); it != itEnd; ++it) &#123; res += s[*it]; &#125; int lenVec = vec.size(); for(int i = 1; i &lt; numRows - 1; i++) &#123; for(int j = 0; j &lt; lenVec; j++) &#123; // 改动的只有下面6行代码 if(vec[j] + i &lt; slen) &#123; res += s[vec[j] + i]; &#125; if(vec[j] + ((numRows - 1) * 2 - i) &lt; slen) &#123; res += s[vec[j] + ((numRows - 1) * 2 - i)]; &#125; &#125; &#125; for(vector&lt;int&gt;::iterator it = vec.begin(); it != itEnd; ++it) &#123; if((*it) + numRows - 1 &lt; slen)res += s[(*it) + numRows - 1]; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem#5 题解]]></title>
    <url>%2Fe493694a%2F</url>
    <content type="text"><![CDATA[题目传送 题意：给出字符串 s ，返回最长回文子串。1 &lt;= s.length &lt;= 1000 思路一（TLE）： 123456789101112131415161718192021222324class Solution&#123;public: string longestPalindrome(string s) &#123; int len = s.length(); string res = ""; int maxLen = 0; for(int i = 0; i &lt; len; i++) &#123; for(int j = 1; i + j &lt;= len; j++) &#123; string str = s.substr(i, j); string pstr = str; reverse(pstr.begin(), pstr.end()); if(pstr.compare(str) == 0) &#123; if(j &gt; maxLen) &#123; res = str; maxLen = j; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 两层循环，遍历所有子串，然后判断该字串是否是回文字符串。不出意外地 TLE 了。然后想半天想不到思路，看了 Solution （链接），然后我选择的是第4个方法。从第一个遍历到最后一个字符，让每个字符当作回文的中心字符，然后得到最长的回文字串。 思路二（AC 代码）： 12345678910111213141516171819202122232425262728293031class Solution&#123;public: string longestPalindrome(string s) &#123; int lenS = s.length(); // 记录字符串的长度，便于直接使用，而不是用一次调用一次length方法 int start = -1, length = -1; for(int i = 0; i &lt; lenS; i++) &#123; int oddLen = lenOfPalindrome(s, i, i); // 假设回文子串为奇数长度 int evenLen = lenOfPalindrome(s, i, i + 1); // 假设回文子串为偶数长度 if(length &lt; oddLen) &#123; // 记录最长长度时的开始字符和长度 start = i - oddLen / 2; length = oddLen; &#125; if(length &lt; evenLen) &#123; // 同上 start = i - evenLen / 2 + 1; length = evenLen; &#125; &#125; return s.substr(start, length); &#125; int lenOfPalindrome(string str, int left, int right) // 对str字符串从left向左遍历，从right向右遍历 &#123; int lenStr = str.length(); while(left &gt;= 0 &amp;&amp; right &lt; lenStr &amp;&amp; str[left] == str[right]) &#123; left--; right++; &#125; return right - left - 1; // 返回长度 &#125;&#125;;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem#3 解题思路]]></title>
    <url>%2F892ce412%2F</url>
    <content type="text"><![CDATA[题目传送 题目概述：给出字符串 s ，找出它的没有重复字符的最长子串 思路1（错误思路）: 1234567891011121314151617181920class Solution&#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char, int&gt; mp; int len = s.length(); int result = 0, tmp = 0; for(int i = 0; i &lt; len; i++) &#123; if(mp.find(s[i]) != mp.end()) &#123; tmp = i - mp[s[i]]; &#125; else &#123; tmp += 1; &#125; mp[s[i]] = i; result = result &lt; tmp ? tmp : result; &#125; return result; &#125;&#125;; 上面代码在测试用例为&quot;abba&quot;的时候出现问题。因为上面第11行的代码，我的想法是如果当前遍历到的字符是重复字符，那就从已经遍历过的字符的下一个字符开始计数，当遍历到&quot;abba&quot;的第二个a的时候，由于mp中已经有了a字符，它会将tmp设置为3，实际上这个子串有重复字符，所以错了。 后来我想到，既然已经遍历到了重复的字符，那么mp里面value值小于第一个重复字符的下标的字符都可以当作删掉了。 思路2（思路1的进化版，然而还是没AC。。。）： 1234567891011121314151617181920212223242526class Solution&#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char, int&gt; mp; int len = s.length(); int result = 0, tmp = 0; int del = 0; for(int i = 0; i &lt; len; i++) &#123; if(mp.find(s[i]) != mp.end()) &#123; if(del &lt; mp[s[i]]) &#123; del = mp[s[i]]; tmp = i - mp[s[i]]; &#125; else &#123; tmp += 1; &#125; &#125; else &#123; tmp += 1; &#125; mp[s[i]] = i; result = result &lt; tmp ? tmp : result; &#125; return result; &#125;&#125;; 没有通过的测试样例是&quot;abcabcbb&quot;，同时我自己测的&quot;abab&quot;也过不了。原因在于del的初始化。。。我把它初始化为0了。。。然后遍历到第二个a的时候，12行条件语句判断之后就会进入else语句，tmp+1。这是明显错误的。将del初始化为-1就可以AC了。 思路3（最终AC代码）: 1234567891011121314151617181920212223242526class Solution&#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char, int&gt; mp; int len = s.length(); int result = 0, tmp = 0; int del = -1; for(int i = 0; i &lt; len; i++) &#123; if(mp.find(s[i]) != mp.end()) &#123; if(del &lt; mp[s[i]]) &#123; del = mp[s[i]]; tmp = i - mp[s[i]]; &#125; else &#123; tmp += 1; &#125; &#125; else &#123; tmp += 1; &#125; mp[s[i]] = i; result = result &lt; tmp ? tmp : result; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心-区间调度问题]]></title>
    <url>%2F614fd3b1%2F</url>
    <content type="text"><![CDATA[题意：有n项工作，每项工作在s[i]时间开始，t[i]时间结束。对于每项工作，你可以选择是否参与。一旦参与就不能中途退出。参与的工作时间段不能重叠（开始的瞬间和结束的瞬间也不能重叠）。 数据范围：$1\leq n\leq 100000$ $1\leq s[i] \leq t[i]\leq 10^9$ 思路：优先选择结束时间最早的工作。 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt; //sort的头文件 #include&lt;utility&gt; //pair的头文件 using namespace std;const int MAX_N = 100000;int n;pair&lt;int, int&gt; p[MAX_N];int main(void)&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; int a, b; //a、b均为临时存储数据的变量 scanf("%d %d", &amp;a, &amp;b); p[i].first = b; //这里将结束时间设置为first，可以便捷地使用sort从小到大排序 p[i].second = a; &#125; sort(p, p + n); //sort对pair排序是对first进行排序，而不是second int cnt = 0, x = 0; //cnt为选择的工作数量，x记录目前选择的工作中最晚结束时间 for(int i = 0; i &lt; n; i++) &#123; if(x &lt; p[i].second) &#123; cnt++; x = p[i].first; &#125; &#125; printf("%d", cnt); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 2020/1/18]]></title>
    <url>%2F5bd2a8c1%2F</url>
    <content type="text"><![CDATA[1039 Course List for Student (25point(s))传送门 题意：输入报名某门课程（以数字为编号）的学生的名字（以三个字母加一个数字为编号），按名字字母序输出每个人名以及对应的报的课程数目及课程。 思路：用unordered_map&lt;string, vector&lt;int&gt; &gt;来存储每个人名对应的课程（unordered_map的key不会进行排序，是通过hash来直接查找元素的，时间复杂度为O(1)，所以节省了时间，map用了红黑树，查找元素时的时间复杂度为O( log(n)））这题我用map时TLE了，而用unordered_map就过了。还有就是，这题如果用scanf和printf来代替cin和cout也可以节省时间，或者用char*代替string。有兴趣的可以把时间改的更少。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;#include&lt;algorithm&gt;using namespace std;unordered_map&lt;string, vector&lt;int&gt; &gt; student;//记录学生姓名对应所选的课程vector&lt;string&gt; name;//记录学生姓名int n, k;//n为学生个数，k为课程总数vector&lt;int&gt; vt;//用于临时存放某个学生所选的课程int main(void)&#123; name.reserve(40001);//这个函数的用法可以去搜一下，有的地方这个函数不可或缺 vt.reserve(2501); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= k; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; string str; for(int j = 1; j &lt;= b; j++) &#123; cin &gt;&gt; str; student[str].push_back(a); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; string na; cin &gt;&gt; na; name.push_back(na); &#125; vector&lt;string&gt;::iterator it; for(it = name.begin(); it != name.end(); it++) &#123; if(student.find(*it) == student.end()) &#123;//当没有找到对应的key时，返回unordered_map::end()，这和map是一样的 cout &lt;&lt; *it &lt;&lt; " 0" &lt;&lt; endl; &#125; else &#123; vt = student[*it]; sort(vt.begin(), vt.end()); cout &lt;&lt; *it &lt;&lt; " " &lt;&lt; vt.size(); vector&lt;int&gt;::iterator itt; for(itt = vt.begin(); itt != vt.end(); itt++) &#123; cout &lt;&lt; " " &lt;&lt; *itt; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 1047 Student List for Course传送门 题意：这题的输入输出和上面那题的输入输出正好相反，输入学生所选的课程，输出选择课程的人名。 思路：正常地使用vector构建二维数组就可以了，这题一开始我用cin和cout还有string超时了，然后我改成scanf和printf还有char*之后就ac了。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;vector&lt;vector&lt;char*&gt; &gt; name;bool cmp(char* a,char *b)&#123; return strcmp(a,b)&lt;0;//按照姓名的字母序排序，不能直接比较&#125;int main(void)&#123; int n, k; //cin &gt;&gt; n &gt;&gt; k; scanf("%d %d",&amp;n,&amp;k); name.resize(k + 1);//这个是构建二维数组时必须的东西，不然报错 for(int i = 1; i &lt;= k; i++) &#123; name[i].reserve(n); &#125; int x; for(int i = 1; i &lt;= n; i++) &#123; //cin &gt;&gt; str &gt;&gt; x; char* str=new char[5]; scanf("%s %d",str,&amp;x); int y; for(int j = 1; j &lt;= x; j++) &#123; //cin &gt;&gt; y; scanf("%d",&amp;y); name[y].push_back(str); &#125; &#125; for(int i = 1; i &lt;= k; i++) &#123; sort(name[i].begin(), name[i].end(),cmp); //cout &lt;&lt; i &lt;&lt; " " &lt;&lt; name[i].size() &lt;&lt; endl; printf("%d %d\n",i,name[i].size()); for(vector&lt;char*&gt;::iterator it = name[i].begin(); it != name[i].end(); it++) &#123; //cout &lt;&lt; *it &lt;&lt; endl; printf("%s\n",*it); &#125; &#125; return 0;&#125; 1100 Mars Numbers传送门 题意：将10进制的数字转换为13进制，然后转换为“火星语”输出，或者输入“火星语”，转换为10进制的数字。 思路：构建map时我没有用string，而是用const char*，所以比较麻烦。当const char*作为key时，map模板第三个参数必须要有，用来排序时的比较。否则会用地址来比较，然后不知道为什么无法使用const char*类型的变量（例如const char* s;）来进行访问，只能使用常量（例如&quot;tret&quot;），这个有兴趣的可以自己搜一下。还有就是13的结果不是tam tret 而是tam。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;cstring&gt;using namespace std;struct cmp &#123;//这是必须要有的，不然无法正常使用map bool operator()(const char *a, const char *b) &#123; return strcmp(a, b) &lt; 0; &#125;&#125;;map&lt;const char*, int, cmp&gt; low;//注意第三个参数map&lt;int, const char*&gt; hlow, hhigh;int charToInt(char *s)//将字符串转换为数字&#123; int len = strlen(s), ans = 0, ii = 1; for(int i = len - 1; i &gt;= 0; i--) &#123; ans += (s[i] - '0') * ii; ii *= 10; &#125; return ans;&#125;int main(void)&#123; low["tret"] = 0; low["jan"] = 1; low["tam"] = 13; low["feb"] = 2; low["hel"] = 26; low["mar"] = 3; low["maa"] = 39; low["apr"] = 4; low["huh"] = 52; low["may"] = 5; low["tou"] = 65; low["jun"] = 6; low["kes"] = 78; low["jly"] = 7; low["hei"] = 91; low["aug"] = 8; low["elo"] = 104; low["sep"] = 9; low["syy"] = 117; low["oct"] = 10; low["lok"] = 130; low["nov"] = 11; low["mer"] = 143; low["dec"] = 12; low["jou"] = 156; hlow[0] = "tret"; hlow[1] = "jan"; hhigh[1] = "tam"; hlow[2] = "feb"; hhigh[2] = "hel"; hlow[3] = "mar"; hhigh[3] = "maa"; hlow[4] = "apr"; hhigh[4] = "huh"; hlow[5] = "may"; hhigh[5] = "tou"; hlow[6] = "jun"; hhigh[6] = "kes"; hlow[7] = "jly"; hhigh[7] = "hei"; hlow[8] = "aug"; hhigh[8] = "elo"; hlow[9] = "sep"; hhigh[9] = "syy"; hlow[10] = "oct"; hhigh[10] = "lok"; hlow[11] = "nov"; hhigh[11] = "mer"; hlow[12] = "dec"; hhigh[12] = "jou"; int n; scanf("%d", &amp;n); getchar(); for(int i = 1; i &lt;= n; i++) &#123; char ch; char s1[4] = &#123;0&#125;, s2[4] = &#123;0&#125;; int ii = 0; char *s = s1; while((ch = getchar()) != '\n') &#123; if(ch != ' ') s[ii++] = ch; else &#123; s = s2; ii = 0; &#125; &#125; if(s1[0] &gt;= '0' &amp;&amp; s1[0] &lt;= '9') &#123; int ans = charToInt(s1); int t1 = ans % 13; ans -= t1; if(ans == 0) &#123; printf("%s\n", hlow[t1]); &#125; else if(t1 == 0) &#123; ans /= 13; printf("%s\n", hhigh[ans]); &#125; else &#123; ans /= 13; printf("%s %s\n", hhigh[ans], hlow[t1]); &#125; &#125; else &#123; if(strlen(s2) == 0) &#123; const char *ss1 = s1; printf("%d\n", low[ss1]); &#125; else &#123; const char *ss1 = s1; const char *ss2 = s2; printf("%d\n", low[ss2] + low[ss1]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019/12/21 题解]]></title>
    <url>%2Fbc1a9440%2F</url>
    <content type="text"><![CDATA[注：本题解的题目缺失 火星上的生命传送门 思路：这题我是用模拟，将A T U变为0 1 2，然后弄个3*3的二维数组，正好对应九个字符串，然后就是将输入的字符串转换为int数组，遍历得到结果。理解上的难点：如果没有遇到end就算None。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;const char* pl[3][3] = &#123;"Glycine", "Cysteine", "START", "END", "END", "Arginine", "Serine", "DELETE", "Lysine"&#125;;int main(void)&#123; string getstr, putstr[20]; int cnt = 0, f[35] = &#123;0&#125;; cin &gt;&gt; getstr; int lg = getstr.length(); for(int i = 0; i &lt; lg; i++) &#123; //将字符转换为数字 if(getstr[i] == 'A') f[i] = 0; else if(getstr[i] == 'T') f[i] = 1; else if(getstr[i] == 'U') f[i] = 2; &#125; for(int i = 0; i &lt; lg - 1; i++) &#123; if(!strcmp(pl[f[i]][f[i + 1]], "START")) &#123; //c语言字符串不能直接比较是否相等，所以用strcmp比较 int j = i + 2; while(strcmp(pl[f[j]][f[j + 1]], "END")) &#123; if(!strcmp(pl[f[j]][f[j + 1]], "DELETE")) cnt--; else putstr[cnt++] = pl[f[j]][f[j + 1]]; j += 2; //判断完了就判断下一个序列 if(j &gt;= lg - 1) &#123; //判断是否有end结尾，如果没有就说明是无效序列 cnt = 0; break; &#125; &#125; break; &#125; &#125; if(cnt &lt;= 0) printf("None"); else &#123; for(int i = 0; i &lt; cnt; i++) &#123; cout &lt;&lt; putstr[i]; if(i != cnt - 1) cout &lt;&lt; ","; &#125; &#125; return 0;&#125; 僵尸危机传送门 思路：这题难点在于理解题意，理解了题意就很简单。 123456789101112131415161718#include&lt;cstdio&gt;int f[1000], a[1000];int main(void)&#123; int n; scanf("%d", &amp;n); f[0] = 1; a[0] = 3; int day = 0; while(a[day] &lt; n) &#123; f[day + 1] = a[day] - (f[day] % 4 ? f[day] / 4 + 1 : f[day] / 4); a[day + 1] = f[day + 1] * 3; day++; &#125; if(day &lt;= 1) printf("%d day", day + 1); //注意是day+1 else printf("%d days", day + 1); return 0;&#125; 再去明星演唱会传送门 思路：简单的dfs，然后用栈（我用的是vector来模拟栈）存储记录点座标的结构体，当到达目标座标的时候，按格式输出栈里面的所有座标，而且要分四次在四个角上使用dfs，如果角上坐了人，就输出-1，或者无法到达目标座标也输出-1，这里用flag来标志是否能到达目标座标。（由于之前刷题时，题目测试数据里面有目标座标可能也坐了人，所以要特判，此时算是到达了目标座标，不过比赛的数据我不知道有没有这种测试数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;int a[20][20], nex[4][2] = &#123;0, -1, -1, 0, 0, 1, 1, 0&#125;, n, m, ex, ey, flag = 0, book[20][20]; //a数组存储某点是否有人，next用于按照左下右上的顺序遍历，book数组用来判断是否已经走过这个点。struct node &#123; int x, y;&#125;;vector&lt;node&gt; ss;//记录已经走过的路径void dfs(int x, int y) //完全是dfs模板，&#123; if(x == ex &amp;&amp; y == ey) &#123; flag = 1; //说明从这个点可以到达目标座标 int len = ss.size(); for(int i = 0; i &lt; len; i++) &#123; printf("(%d,%d)", ss[i].x, ss[i].y); if(i != len - 1) printf("-&gt;"); &#125; printf("\n"); return ; &#125; for(int i = 0; i &lt; 4; i++) &#123; int tx = x + nex[i][0]; int ty = y + nex[i][1]; if(tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; m || book[tx][ty] || (a[tx][ty] == 1 &amp;&amp; !(tx == ex &amp;&amp; ty == ey))) continue; //这里的最后括号里面的特判是因为目标座标可能有人，也算可以到达，这是因为之前有个数据卡了我很多次。。。这个比赛的数据我不知道有没有卡。。。 book[tx][ty] = 1; node tn; tn.x = tx; tn.y = ty; ss.push_back(tn); dfs(tx, ty); ss.pop_back(); book[tx][ty] = 0; &#125;&#125;int main(void)&#123; scanf("%d %d", &amp;ex, &amp;ey); scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; int beg[4][2] = &#123;1, 1, 1, m, n, 1, n, m&#125;; for(int i = 0; i &lt; 4; i++) &#123; flag = 0; if(a[beg[i][0]][beg[i][1]] == 1) &#123; //判断角上是否有人，有人就不能走 printf("-1\n"); continue; &#125; for(int ii = 1; ii &lt;= n; ii++) &#123; for(int j = 1; j &lt;= m; j++) &#123; book[ii][j] = 0; &#125; &#125; book[beg[i][0]][beg[i][1]] = 1; node tn; tn.x = beg[i][0]; tn.y = beg[i][1]; ss.push_back(tn); dfs(beg[i][0], beg[i][1]); ss.pop_back(); book[beg[i][0]][beg[i][1]] = 0; if(flag == 0) &#123; //这个角无法到达目标座标 printf("-1\n"); &#125; &#125; return 0;&#125; 摸鱼传送门 思路：这题我是用一个结构体存储每个人的编号、随机数、对他%的人数。每当输入一个朋友关系的时候，判断谁的随机数大，然后大的那个人的 对他%的人数 减一（就是减掉他的朋友），然后把这个结构体数组按照随机数大小从小到大排序，然后根据下标计算每个人的对他%的人数，再按照编号排序，输出%他的人数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int f[200100];struct node &#123; int num, random; int bai;&#125; ss[200100];bool cmp(node a, node b)&#123; if(a.random != b.random) return a.random &lt; b.random; return a.num &lt; b.num;&#125;bool cmp1(node a, node b)&#123; return a.num &lt; b.num;&#125;int main(void)&#123; int n, k; scanf("%d %d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;ss[i].random); ss[i].num = i; ss[i].bai = 0; &#125; for(int i = 1; i &lt;= k; i++) &#123; int a, b; scanf("%d %d", &amp;a, &amp;b); if(ss[a].random &lt; ss[b].random) ss[b].bai--; else if(ss[a].random &gt; ss[b].random) ss[a].bai--; &#125; sort(ss + 1, ss + n + 1, cmp); int cnt = 0; for(int i = 2; i &lt;= n; i++) &#123; //这是重点代码，判断有几个人的随机数小于现在这个人 if(ss[i - 1].random == ss[i].random) ss[i].bai += cnt; else &#123; cnt = i - 1; ss[i].bai += cnt; &#125; &#125; /* printf("\n"); for(int i=1;i&lt;=n;i++)&#123; printf("%d",ss[i].random); if(i!=n) printf(" "); &#125; */ sort(ss + 1, ss + n + 1, cmp1); for(int i = 1; i &lt;= n; i++) &#123; printf("%d", ss[i].bai &lt; 0 ? 0 : ss[i].bai); if(i != n) printf(" "); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解]]></title>
    <url>%2Ffbf2b730%2F</url>
    <content type="text"><![CDATA[洛谷 p2812 回家链接 思路：直接用dfs搜索，需要注意的是当移动时，有的点只可以经过一次（起点和鼠标所在的点，防止走回头路），有的点则可以经过两次（一次是残血，一次是走到附近加了血之后）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;int flag = 0, n, m, a[10][10], hp = 6, min = 0x3f3f3f3f, sum = 0, book[10][10];int next[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;void dfs(int x, int y)&#123; if(hp == 0) return; //此时没血了,不能走了 if(a[x][y] == 4) &#123; //到达鼠标所在的点 hp = 6; book[x][y] = 1; &#125; if(a[x][y] == 3) &#123; //到达终点 flag = 1; min = sum &lt; min ? sum : min; return; &#125; int tx, ty; for(int i = 0; i &lt; 4; i++) &#123; tx = x + next[i][0]; ty = y + next[i][1]; if(a[tx][ty] == 2 || tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m || a[tx][ty] == 0 || (a[tx][ty] == 4 &amp;&amp; book[tx][ty] == 1) || book[tx][ty] == 2 ) continue; int t = hp; hp--; sum++; book[tx][ty]++; dfs(tx, ty); book[tx][ty]--; sum--; hp = t; &#125; return;&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; int x, y; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(2 == a[i][j]) &#123; x = i; y = j; &#125; &#125; &#125; dfs(x, y); if(flag == 1) printf("%d", min); else printf("-1"); return 0;&#125; 洛谷 p1443 马的遍历链接 思路：直接套模板。。。bfs。。。（虽然很水，但可以复习bfs模板。。。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;int n, m, startx, starty, a[401][401], book[401][401], next[8][2] = &#123;2, 1, 1, 2, -1, 2, -2, 1, -2, -1, -1, -2, 1, -2, 2, -1&#125;;bool judge(int x, int y)&#123; if(x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m) &#123; return false; &#125; return true;&#125;struct node &#123; int x; int y; int step;&#125; que[160001];int main(void)&#123; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;startx, &amp;starty); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; a[i][j] = -1; &#125; &#125; a[startx][starty] = 0; book[startx][starty] = 1; int head = 1, tail = 1; que[tail].x = startx; que[tail].y = starty; que[tail].step = 0; tail++; while(head &lt; tail) &#123; for(int i = 0; i &lt; 8; i++) &#123; int tx = que[head].x + next[i][0]; int ty = que[head].y + next[i][1]; if(book[tx][ty] == 1 || !judge(tx, ty) ) continue; que[tail].x = tx; que[tail].y = ty; a[tx][ty] = que[tail].step = que[head].step + 1; tail++; book[tx][ty] = 1; &#125; head++; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; printf("%-5d", a[i][j]); &#125; printf("\n"); &#125; return 0;&#125; 洛谷 p1892 团伙链接 思路：这是一个并查集的题目，需要注意的就是，敌人的敌人是朋友，所以在判断敌人时，要多弄一个把敌人的敌人合并为朋友的语句。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int n, m, f[1001], e[1001];int getf(int u)&#123; if(f[u] == u) return u; f[u] = getf(f[u]); return f[u];&#125;bool merge(int u, int v)&#123; int t1 = getf(u); int t2 = getf(v); if(t1 == t2) return false; f[v] = t1; return true;&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; f[i] = i; e[i] = 0; &#125; for(int i = 1; i &lt;= m; i++) &#123; char ch; int p, q; //scanf("%c %d %d",&amp;ch,&amp;p,&amp;q); cin &gt;&gt; ch &gt;&gt; p &gt;&gt; q; if(ch == 'F') &#123; merge(p, q); &#125; else if(ch == 'E') &#123; if(e[p] != 0) &#123; merge(e[p], q); &#125; else e[p] = q; if(e[q] != 0) &#123; merge(e[q], p); &#125; else e[q] = p; &#125; &#125; int sum = 0; for(int i = 1; i &lt;= n; i++) &#123; if(f[i] == i) sum++; &#125; printf("%d", sum); return 0;&#125; 洛谷 p2024食物链链接 思路：这题我没想到思路，通过看题解的思路来写代码。这题是种类并查集 的题目，通过将初始数组的大小置为n的倍数，然后将数组划分为若干个集合（1 ~ n , n+1 ~ 2n , … 每个集合里面有n个元素），第二个集合是第一个集合的天敌，第三个集合是第二个集合的天敌，第一个集合是第三个集合的天敌，然后通过将同类动物放在同一个集合里讨论，不同类动物（敌对）则在不同的集合里面讨论。当对动物进行合并时，要同时对不同的集合进行操作。当对输入的东西进行讨论是则只需要只需要对一组集合进行讨论就可以了。（种类并查集求的并非具体种类，而是关系！）参考的题解链接 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;int n, k, f[150001];int getf(int u) //找同类&#123; return f[u] == u ? u : f[u] = getf(f[u]);&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;k); for(int i = 1; i &lt;= n * 3; i++) f[i] = i; int a, x, y, sum = 0; for(; k; k--) &#123; scanf("%d %d %d", &amp;a, &amp;x, &amp;y); if(x &gt; n || y &gt; n) &#123; sum++; continue; &#125; if(a == 1) &#123; if(getf(x) == getf(y + n) || getf(x + n) == getf(y)) &#123; //当x和y时互相为天敌时，这个输入的语句为假 sum++; &#125; else &#123; //将x和y设置为同类(三个集合都要设置) f[getf(x)] = getf(y); f[getf(x + n)] = getf(y + n); f[getf(x + 2 * n)] = getf(y + 2 * n); &#125; &#125; else &#123; if(getf(x) == getf(y) || getf(x + n) == getf(y)) &#123; //判断是否是同类 sum++; &#125; else &#123; //将x和y设置为天敌关系 f[getf(x)] = getf(y + n); f[getf(x + n)] = getf(y + 2 * n); f[getf(x + 2 * n)] = getf(y); &#125; &#125; &#125; printf("%d", sum); return 0;&#125; 洛谷 p3371 【模板】单源最短路径（弱化版）链接 思路：这题如果用邻接矩阵会有三个MLE，原因是邻接矩阵数组过大（10000 X 10000），然后用了一些时间学习链式前向星。所以我最后ac的解法是Dijkstra+链式前向星 。还有就是用快读的方式减少运行时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#define Maxn 10001const int inf = 0x3f3f3f3f;int n, m, s, dis[Maxn], book[Maxn];int cnt = 1, head[Maxn] = &#123;0&#125;; //head用来记录以某个起点的第一条边，cnt用来记录edge的当前下标struct Edge &#123; int next;//（同一起点）下一条边的数组下标 int to;//边的终点 int w;//边的长度(权)&#125; edge[500001];void add(int u, int v, int w) //将以u为起点v为终点的边存储到链式前向星里面&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++;&#125;int read(void) //快读&#123; char ch = getchar(); int n = 0; while(ch &lt; '0' || ch &gt; '9') ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; n = (n &lt;&lt; 1) + (n &lt;&lt; 3) + ( ch &amp; 15 ); ch = getchar(); &#125; return n;&#125;int main(void)&#123; n = read(); m = read(); s = read(); for(int i = 1; i &lt;= n; i++) dis[i] = inf; dis[s] = 0; for(; m; m--) &#123; int u, v, w; u = read(); v = read(); w = read(); add(u, v, w); &#125; int t = s, min = inf; while(!book[t]) &#123; //条件为当dis存在未确定的边里面的最小边,至于原因可以看dijkstra算法 book[t] = 1; for(int i = head[t]; i; i = edge[i].next) &#123; //从某一始点的第一条边开始遍历，松弛dis数组 if(!book[edge[i].to] &amp;&amp; dis[edge[i].to] &gt; dis[t] + edge[i].w) dis[edge[i].to] = dis[t] + edge[i].w; &#125; min = inf; for(int i = 1; i &lt;= n; i++) &#123; //查看是否所有点已经松弛完成，即所有点都确定了 if(!book[i] &amp;&amp; dis[i] &lt; min) &#123; t = i; min = dis[i]; &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; if(dis[i] != inf) printf("%d ", dis[i]); else printf("2147483647 "); &#125; return 0;&#125; 洛谷 P1462 通往奥格瑞玛的道路链接 思路：这题我写了两天（改代码和学习，我太菜了）。。。题意的交费最多的最小值就是当他能到达终点时，肯定有个收费最多的点，在所有可能的路径中，收费最多的点的最小值。用dijkstra+二分来写（还要用堆优化，不然会tle。。。卡了将近一天），主要是将点权二分，然后找最短满足点权条件的最短路径，一直二分，最后找到满足条件的最小值。堆优化就是找出利用priority_queue（大佬也可以用手写最小堆）来记录dijkstra里面遍历到的点，其中要自定义一个struct cmp 来作为模板参数的第三个参数（以!cmp录入，和sort函数不同）。然后就是二分后的top（将大于top的点直接排除）要作为check函数里面部分条件的判断依据（如代码）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MAXn = 10001; //最大的点的数目const int inf = 0x3f3f3f3f;int cnt = 1, dis[MAXn], book[MAXn] = &#123;0&#125;, n, m, b, head[MAXn], f[MAXn];struct cmp &#123; //我没试直接写个cmp函数可不可以。。。 bool operator()(int &amp;a, int &amp;b) const &#123; //因为优先出列判定为!cmp，所以反向定义实现最小值优先 return dis[a] &gt; dis[b]; &#125;&#125;;void quicksort(int *p, int left, int right) //快排。。。（tle后各种优化，连sort都换了）&#123; if(left &gt; right) return; int temp = p[left]; int l = left, r = right; while(l != r) &#123; while(p[r] &gt;= temp &amp;&amp; l &lt; r) r--; while(p[l] &lt;= temp &amp;&amp; l &lt; r) l++; if(l &lt; r) &#123; int t = p[l]; p[l] = p[r]; p[r] = t; &#125; &#125; p[left] = p[l]; p[l] = temp; quicksort(p, left, l - 1); quicksort(p, l + 1, right);&#125;int read(void)&#123; int n = 0; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; n = (n &lt;&lt; 1) + (n &lt;&lt; 3) + (ch &amp; 15); ch = getchar(); &#125; return n;&#125;struct Edge &#123; int next; int to; int w;&#125; edge[2 * 50001];void add(int u, int v, int w)&#123; edge[cnt].w = w; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt++;&#125;bool check(int top)&#123; if(top &lt; f[1] || top &lt; f[n]) return false; int t; for(int i = 1; i &lt;= n; i++) &#123; dis[i] = inf; book[i] = 0; &#125; dis[1] = 0; priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; pq; //用堆记录dis里面未松弛的点里面的最小值的点 pq.push(1); while(!pq.empty()) &#123; t = pq.top(); pq.pop(); if(book[t] || top &lt; f[t]) continue; //如果已经松弛或者当前点收费大于top时 book[t] = 1; for(int i = head[t]; i; i = edge[i].next) &#123; //边的遍历，对dis松弛. if(f[edge[i].to] &lt;= top &amp;&amp; !book[edge[i].to] &amp;&amp; dis[edge[i].to] &gt; dis[t] + edge[i].w) &#123; dis[edge[i].to] = dis[t] + edge[i].w; pq.push(edge[i].to); &#125; &#125; &#125; return dis[n] &lt;= b;&#125;int main(void)&#123; n = read(); m = read(); b = read(); int c[MAXn] = &#123;0&#125;; for(int i = 1; i &lt;= n; i++) &#123; f[i] = read(); c[i] = f[i]; &#125; int u, v, w; for(int i = 1; i &lt;= m; i++) &#123; u = read(); v = read(); w = read(); if(u == v) continue; add(u, v, w); add(v, u, w); &#125; quicksort(c, 1, n); int l = 1, r = n, mid; if(!check(c[n])) &#123; //判断是否有到达终点的路径 printf("AFK\n"); return 0; &#125; int ans = c[n]; while(l &lt;= r) &#123; //对点的费用按大小进行二分 mid = (l + r) &gt;&gt; 1; if(check(c[mid])) &#123; r = mid - 1; ans = c[mid]; &#125; else l = mid + 1; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
        <tag>并查集</tag>
        <tag>单源最短路径</tag>
        <tag>dijkstra</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01迷宫]]></title>
    <url>%2Fd877abb7%2F</url>
    <content type="text"><![CDATA[01迷宫 题目链接(洛谷) 这题主要是理解题目意思，我一开始以为这题描述的是求能走的最长路径，后来wa了找不出问题，看了题解才知道原来不是求最长路径，而是求从某点能到达的所有的点的总数（包括自己）。理解了题意就容易了，我用的方法是先dfs+染色，再根据输入的位置来输出结果。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;int a[1001][1001], book[1001][1001], f[1000001], n, m; //数组a保存地图，数组book记录染色情况，数组f记录某个颜色总大小int next[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;; //前进的方向int read(void) //快读&#123; char ch = getchar(); while(ch != '1' &amp;&amp; ch != '0') ch = getchar(); return ch &amp; 1;&#125;void dfs(int aa, int bb, int color) //aa和bb为位置，color为当前染色的颜色&#123; int tx, ty; for(int i = 0; i &lt; 4; i++) &#123; tx = aa + next[i][0]; ty = bb + next[i][1]; if(tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; n || book[tx][ty] || a[tx][ty] == a[aa][bb]) continue; f[color]++; book[tx][ty] = color; dfs(tx, ty, color); &#125;&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; a[i][j] = read(); &#125; &#125; int c = 1; //颜色 for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(!book[i][j]) &#123;//当前点未经过染色 f[c] = 1; //把当前点也记录进去 book[i][j] = c; //开始染色 dfs(i, j, c++); &#125; &#125; &#125; int x, y; for(int i = 1; i &lt;= m; i++) &#123; //读入点的坐标 scanf("%d %d", &amp;x, &amp;y); printf("%d", f[book[x][y]]); //输出当前颜色占据的总大小，即当前点能到达的所有的点的数目 if(i != m) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂和矩阵的快速幂]]></title>
    <url>%2F6b81fe2c%2F</url>
    <content type="text"><![CDATA[快速幂和矩阵的快速幂求an的值，可以一个一个乘起来，也可以转化为其他多个数想乘，例如an=an/2* an/2=an/3* an/3* an/3=…，当n的值非常大的时候，这两种求法效率明显不够高，所以就有大佬想出了快速幂的算法，快速幂算法的主要代码如下： 12345678int res=1;//res为记录结果的变量void pow(int a,int n)&#123; while(n)&#123; if(n&amp;1) res*=a; n&gt;&gt;=1; a*=a; &#125;&#125; 如果看代码无法理解（反正我开始直接看代码是没理解），则可以结合例子看代码： 276=201001100B(2进制)=2100B* 21000B* 21000000B=24* 28 * 264 而矩阵的快速幂算法则差不多是一样的，下面为题目贴图和代码： 方阵的阶乘 描述 给定一个N阶方阵A，输出A的M次幂对10000求余的值（M是非负整数） 输入 第一行是一个正整数N、M（1&lt;=N&lt;=50, 0&lt;=M&lt;=7.5e18），表示方阵A的阶数和要求的幂数 接下来N行，每行N个绝对值不超过10的非负整数，描述方阵A的值 输出 输出共N行，每行N个整数，表示A的M次幂所对应的方阵对10000求余数。相邻的数之间用一个空格隔开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;int a[51][51], b[51][51]; //a为当前输入的矩阵，b为记录结果的矩阵int n;void cheng(int x[][51], int y[][51]) //x*=y(x和y为矩阵)&#123; int sum = 0, z[51][51] = &#123;0&#125;; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; for(int k = 1; k &lt;= n; k++) &#123; sum += x[i][k] * y[k][j]; &#125; z[i][j] = sum % 10000; sum = 0; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; x[i][j] = z[i][j]; &#125; &#125;&#125;void mi(int x[][51], long long int m)&#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(i == j) b[i][j] = 1; //注意记录结果的数组初始值设置 &#125; &#125; while(m) &#123; //主要代码 if(m &amp; 1) &#123; cheng(b, x); &#125; m &gt;&gt;= 1; cheng(x, x); &#125;&#125;int main(void)&#123; long long int m; scanf("%d %lld", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; mi(a, m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; printf("%d", b[i][j]); if(j != n) printf(" "); &#125; if(i != n) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[To Fill or Not to Fill]]></title>
    <url>%2F21fcb834%2F</url>
    <content type="text"><![CDATA[题目：To Fill or Not to Fill` 传送门 这题主要是贪心，然后就是细节了，首先，输入的数字除了N以外都要用double（不能用float，不然有大的数据会通不过），具体思路是：1.当加油站之间的距离或与终点的距离大于满油时能行驶的最大距离时，要输出最大距离。2.在加油站的一定距离以内，第一个价格比当前加油站价格低的加油站为下一个需要直接到达的加油站。3.若在加油站以内没有比当前加油站价格低的加油站，则加满油后直接去最价格相对最低的加油站。4.若当前加油站能直接到达终点，且范围内没有价格更低的加油站时，直接到达终点（即使是最后一个加油站也是如此判断）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int N, cur, minn;double Cmax, D, Davg, oil = 0.0;const double inf = 0x3f3f3f3f;struct ss &#123; double m; double p;&#125; qq[510];bool cmp(ss a, ss b)&#123; return a.p &lt; b.p;&#125;int find(void)&#123; minn = cur; double min = inf; if(qq[cur + 1].p - qq[cur].p &gt; Cmax * Davg) return -1; int i; for(i = cur + 1; qq[i].p - qq[cur].p &lt;= Cmax * Davg &amp;&amp; i &lt; N; i++) &#123; if(qq[i].m &lt; qq[cur].m) &#123; minn = i; break; &#125; &#125; if(minn == cur) &#123; for(int j = cur + 1; qq[j].p - qq[cur].p &lt;= Cmax * Davg &amp;&amp; j &lt; N; j++) &#123; if(qq[j].m &lt; min) &#123; min = qq[j].m; minn = j; &#125; &#125; return cur; &#125; else &#123; return minn; &#125;&#125;int main(void)&#123; scanf("%lf %lf %lf %d", &amp;Cmax, &amp;D, &amp;Davg, &amp;N); cur = 0; for(int i = 0; i &lt; N; i++) &#123; scanf("%lf %lf", &amp;qq[i].m, &amp;qq[i].p); &#125; qq[N].p = D; //printf("%d\n",qq[0].p); stable_sort(qq, qq + N, cmp); //printf("%d\n",qq[0].p); if(qq[0].p != 0) &#123; printf("The maximum travel distance = 0.00"); return 0; &#125; double maxm = 0.0, maxp = 0; int r; bool flag = 1; cur = 0; while(flag) &#123; r = find(); //printf("%d\n",r); //printf("--%d\n",cur); if(r == -1) &#123; maxp = qq[cur].p + Cmax * Davg; flag = 0; break; &#125; else if(r == cur) &#123; if(qq[cur].p + Cmax * Davg &gt;= D) &#123; maxm += qq[cur].m * ((D - qq[cur].p) / Davg - oil); break; &#125; maxm += (Cmax - oil) * qq[cur].m; oil = Cmax - (qq[minn].p - qq[cur].p) / Davg; cur = minn; &#125; else &#123; maxm += ((qq[r].p - qq[cur].p) / Davg - oil) * qq[cur].m; oil = 0.0; cur = r; &#125; &#125; if(flag == 0) &#123; printf("The maximum travel distance = %.2lf", maxp); &#125; else &#123; printf("%.2lf", maxm); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
