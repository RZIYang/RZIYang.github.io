<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Problem#5 题解]]></title>
    <url>%2Fe493694a%2F</url>
    <content type="text"><![CDATA[题目传送 题意：给出字符串 s ，返回最长回文子串。1 &lt;= s.length &lt;= 1000 思路一（TLE）： 123456789101112131415161718192021222324class Solution&#123;public: string longestPalindrome(string s) &#123; int len = s.length(); string res = ""; int maxLen = 0; for(int i = 0; i &lt; len; i++) &#123; for(int j = 1; i + j &lt;= len; j++) &#123; string str = s.substr(i, j); string pstr = str; reverse(pstr.begin(), pstr.end()); if(pstr.compare(str) == 0) &#123; if(j &gt; maxLen) &#123; res = str; maxLen = j; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 两层循环，遍历所有子串，然后判断该字串是否是回文字符串。不出意外地 TLE 了。然后想半天想不到思路，看了 Solution （链接），然后我选择的是第4个方法。从第一个遍历到最后一个字符，让每个字符当作回文的中心字符，然后得到最长的回文字串。 思路二（AC 代码）： 12345678910111213141516171819202122232425262728293031class Solution&#123;public: string longestPalindrome(string s) &#123; int lenS = s.length(); // 记录字符串的长度，便于直接使用，而不是用一次调用一次length方法 int start = -1, length = -1; for(int i = 0; i &lt; lenS; i++) &#123; int oddLen = lenOfPalindrome(s, i, i); // 假设回文子串为奇数长度 int evenLen = lenOfPalindrome(s, i, i + 1); // 假设回文子串为偶数长度 if(length &lt; oddLen) &#123; // 记录最长长度时的开始字符和长度 start = i - oddLen / 2; length = oddLen; &#125; if(length &lt; evenLen) &#123; // 同上 start = i - evenLen / 2 + 1; length = evenLen; &#125; &#125; return s.substr(start, length); &#125; int lenOfPalindrome(string str, int left, int right) // 对str字符串从left向左遍历，从right向右遍历 &#123; int lenStr = str.length(); while(left &gt;= 0 &amp;&amp; right &lt; lenStr &amp;&amp; str[left] == str[right]) &#123; left--; right++; &#125; return right - left - 1; // 返回长度 &#125;&#125;;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Problem#3 解题思路]]></title>
    <url>%2F892ce412%2F</url>
    <content type="text"><![CDATA[题目传送 题目概述：给出字符串 s ，找出它的没有重复字符的最长子串 思路1（错误思路）: 1234567891011121314151617181920class Solution&#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char, int&gt; mp; int len = s.length(); int result = 0, tmp = 0; for(int i = 0; i &lt; len; i++) &#123; if(mp.find(s[i]) != mp.end()) &#123; tmp = i - mp[s[i]]; &#125; else &#123; tmp += 1; &#125; mp[s[i]] = i; result = result &lt; tmp ? tmp : result; &#125; return result; &#125;&#125;; 上面代码在测试用例为”abba”的时候出现问题。因为上面第11行的代码，我的想法是如果当前遍历到的字符是重复字符，那就从已经遍历过的字符的下一个字符开始计数，当遍历到”abba”的第二个a的时候，由于mp(map)中已经有了a字符，它会将tmp设置为3，实际上这个子串有重复字符，所以错了。 后来我想到，既然已经遍历到了重复的字符，那么mp里面value小于第一个重复字符的下标的字符都可以当作删掉了。 思路2（思路1的进化版，然而还是没AC。。。）： 1234567891011121314151617181920212223242526class Solution&#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char, int&gt; mp; int len = s.length(); int result = 0, tmp = 0; int del = 0; for(int i = 0; i &lt; len; i++) &#123; if(mp.find(s[i]) != mp.end()) &#123; if(del &lt; mp[s[i]]) &#123; del = mp[s[i]]; tmp = i - mp[s[i]]; &#125; else &#123; tmp += 1; &#125; &#125; else &#123; tmp += 1; &#125; mp[s[i]] = i; result = result &lt; tmp ? tmp : result; &#125; return result; &#125;&#125;; 没有通过的测试样例是”abcabcbb”，同时我自己测的”abab”也过不了。原因在于del的初始化。。。我把它初始化为0了。。。然后遍历到第二个a的时候，12行条件语句判断之后就会进入else语句，tmp+1。这是明显错误的。将del初始化为-1就可以ac了。 思路3（最终AC代码）: 1234567891011121314151617181920212223242526class Solution&#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char, int&gt; mp; int len = s.length(); int result = 0, tmp = 0; int del = -1; for(int i = 0; i &lt; len; i++) &#123; if(mp.find(s[i]) != mp.end()) &#123; if(del &lt; mp[s[i]]) &#123; del = mp[s[i]]; tmp = i - mp[s[i]]; &#125; else &#123; tmp += 1; &#125; &#125; else &#123; tmp += 1; &#125; mp[s[i]] = i; result = result &lt; tmp ? tmp : result; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心-区间调度问题]]></title>
    <url>%2F614fd3b1%2F</url>
    <content type="text"><![CDATA[题意：有n项工作，每项工作在s[i]时间开始，t[i]时间结束。对于每项工作，你可以选择是否参与。一旦参与就不能中途退出。参与的工作时间段不能重叠（开始的瞬间和结束的瞬间也不能重叠）。 数据范围：$1\leq n\leq 100000$ $1\leq s[i] \leq t[i]\leq 10^9$ 思路：优先选择结束时间最早的工作。 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt; //sort的头文件 #include&lt;utility&gt; //pair的头文件 using namespace std;const int MAX_N = 100000;int n;pair&lt;int, int&gt; p[MAX_N];int main(void)&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; int a, b; //a、b均为临时存储数据的变量 scanf("%d %d", &amp;a, &amp;b); p[i].first = b; //这里将结束时间设置为first，可以便捷地使用sort从小到大排序 p[i].second = a; &#125; sort(p, p + n); //sort对pair排序是对first进行排序，而不是second int cnt = 0, x = 0; //cnt为选择的工作数量，x记录目前选择的工作中最晚结束时间 for(int i = 0; i &lt; n; i++) &#123; if(x &lt; p[i].second) &#123; cnt++; x = p[i].first; &#125; &#125; printf("%d", cnt); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 2020/1/18]]></title>
    <url>%2F5bd2a8c1%2F</url>
    <content type="text"><![CDATA[1039 Course List for Student (25point(s))传送门 题意：输入报名某门课程（以数字为编号）的学生的名字（以三个字母加一个数字为编号），按名字字母序输出每个人名以及对应的报的课程数目及课程。 思路：用unordered_map&lt;string, vector&lt;int&gt; &gt;来存储每个人名对应的课程（unordered_map的key不会进行排序，是通过hash来直接查找元素的，时间复杂度为O(1)，所以节省了时间，map用了红黑树，查找元素时的时间复杂度为O( log(n)））这题我用map时TLE了，而用unordered_map就过了。还有就是，这题如果用scanf和printf来代替cin和cout也可以节省时间，或者用char*代替string。有兴趣的可以把时间改的更少。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;#include&lt;algorithm&gt;using namespace std;unordered_map&lt;string, vector&lt;int&gt; &gt; student;//记录学生姓名对应所选的课程vector&lt;string&gt; name;//记录学生姓名int n, k;//n为学生个数，k为课程总数vector&lt;int&gt; vt;//用于临时存放某个学生所选的课程int main(void)&#123; name.reserve(40001);//这个函数的用法可以去搜一下，有的地方这个函数不可或缺 vt.reserve(2501); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= k; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; string str; for(int j = 1; j &lt;= b; j++) &#123; cin &gt;&gt; str; student[str].push_back(a); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; string na; cin &gt;&gt; na; name.push_back(na); &#125; vector&lt;string&gt;::iterator it; for(it = name.begin(); it != name.end(); it++) &#123; if(student.find(*it) == student.end()) &#123;//当没有找到对应的key时，返回unordered_map::end()，这和map是一样的 cout &lt;&lt; *it &lt;&lt; " 0" &lt;&lt; endl; &#125; else &#123; vt = student[*it]; sort(vt.begin(), vt.end()); cout &lt;&lt; *it &lt;&lt; " " &lt;&lt; vt.size(); vector&lt;int&gt;::iterator itt; for(itt = vt.begin(); itt != vt.end(); itt++) &#123; cout &lt;&lt; " " &lt;&lt; *itt; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 1047 Student List for Course传送门 题意：这题的输入输出和上面那题的输入输出正好相反，输入学生所选的课程，输出选择课程的人名。 思路：正常地使用vector构建二维数组就可以了，这题一开始我用cin和cout还有string超时了，然后我改成scanf和printf还有char*之后就ac了。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;vector&lt;vector&lt;char*&gt; &gt; name;bool cmp(char* a,char *b)&#123; return strcmp(a,b)&lt;0;//按照姓名的字母序排序，不能直接比较&#125;int main(void)&#123; int n, k; //cin &gt;&gt; n &gt;&gt; k; scanf("%d %d",&amp;n,&amp;k); name.resize(k + 1);//这个是构建二维数组时必须的东西，不然报错 for(int i = 1; i &lt;= k; i++) &#123; name[i].reserve(n); &#125; int x; for(int i = 1; i &lt;= n; i++) &#123; //cin &gt;&gt; str &gt;&gt; x; char* str=new char[5]; scanf("%s %d",str,&amp;x); int y; for(int j = 1; j &lt;= x; j++) &#123; //cin &gt;&gt; y; scanf("%d",&amp;y); name[y].push_back(str); &#125; &#125; for(int i = 1; i &lt;= k; i++) &#123; sort(name[i].begin(), name[i].end(),cmp); //cout &lt;&lt; i &lt;&lt; " " &lt;&lt; name[i].size() &lt;&lt; endl; printf("%d %d\n",i,name[i].size()); for(vector&lt;char*&gt;::iterator it = name[i].begin(); it != name[i].end(); it++) &#123; //cout &lt;&lt; *it &lt;&lt; endl; printf("%s\n",*it); &#125; &#125; return 0;&#125; 1100 Mars Numbers传送门 题意：将10进制的数字转换为13进制，然后转换为“火星语”输出，或者输入“火星语”，转换为10进制的数字。 思路：构建map时我没有用string，而是用const char*，所以比较麻烦。当const char*作为key时，map模板第三个参数必须要有，用来排序时的比较。否则会用地址来比较，然后不知道为什么无法使用const char*类型的变量（例如const char* s;）来进行访问，只能使用常量（例如&quot;tret&quot;），这个有兴趣的可以自己搜一下。还有就是13的结果不是tam tret 而是tam。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;cstring&gt;using namespace std;struct cmp &#123;//这是必须要有的，不然无法正常使用map bool operator()(const char *a, const char *b) &#123; return strcmp(a, b) &lt; 0; &#125;&#125;;map&lt;const char*, int, cmp&gt; low;//注意第三个参数map&lt;int, const char*&gt; hlow, hhigh;int charToInt(char *s)//将字符串转换为数字&#123; int len = strlen(s), ans = 0, ii = 1; for(int i = len - 1; i &gt;= 0; i--) &#123; ans += (s[i] - '0') * ii; ii *= 10; &#125; return ans;&#125;int main(void)&#123; low["tret"] = 0; low["jan"] = 1; low["tam"] = 13; low["feb"] = 2; low["hel"] = 26; low["mar"] = 3; low["maa"] = 39; low["apr"] = 4; low["huh"] = 52; low["may"] = 5; low["tou"] = 65; low["jun"] = 6; low["kes"] = 78; low["jly"] = 7; low["hei"] = 91; low["aug"] = 8; low["elo"] = 104; low["sep"] = 9; low["syy"] = 117; low["oct"] = 10; low["lok"] = 130; low["nov"] = 11; low["mer"] = 143; low["dec"] = 12; low["jou"] = 156; hlow[0] = "tret"; hlow[1] = "jan"; hhigh[1] = "tam"; hlow[2] = "feb"; hhigh[2] = "hel"; hlow[3] = "mar"; hhigh[3] = "maa"; hlow[4] = "apr"; hhigh[4] = "huh"; hlow[5] = "may"; hhigh[5] = "tou"; hlow[6] = "jun"; hhigh[6] = "kes"; hlow[7] = "jly"; hhigh[7] = "hei"; hlow[8] = "aug"; hhigh[8] = "elo"; hlow[9] = "sep"; hhigh[9] = "syy"; hlow[10] = "oct"; hhigh[10] = "lok"; hlow[11] = "nov"; hhigh[11] = "mer"; hlow[12] = "dec"; hhigh[12] = "jou"; int n; scanf("%d", &amp;n); getchar(); for(int i = 1; i &lt;= n; i++) &#123; char ch; char s1[4] = &#123;0&#125;, s2[4] = &#123;0&#125;; int ii = 0; char *s = s1; while((ch = getchar()) != '\n') &#123; if(ch != ' ') s[ii++] = ch; else &#123; s = s2; ii = 0; &#125; &#125; if(s1[0] &gt;= '0' &amp;&amp; s1[0] &lt;= '9') &#123; int ans = charToInt(s1); int t1 = ans % 13; ans -= t1; if(ans == 0) &#123; printf("%s\n", hlow[t1]); &#125; else if(t1 == 0) &#123; ans /= 13; printf("%s\n", hhigh[ans]); &#125; else &#123; ans /= 13; printf("%s %s\n", hhigh[ans], hlow[t1]); &#125; &#125; else &#123; if(strlen(s2) == 0) &#123; const char *ss1 = s1; printf("%d\n", low[ss1]); &#125; else &#123; const char *ss1 = s1; const char *ss2 = s2; printf("%d\n", low[ss2] + low[ss1]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019/12/21 题解]]></title>
    <url>%2Fbc1a9440%2F</url>
    <content type="text"><![CDATA[注：本题解的题目缺失 火星上的生命传送门 思路：这题我是用模拟，将A T U变为0 1 2，然后弄个3*3的二维数组，正好对应九个字符串，然后就是将输入的字符串转换为int数组，遍历得到结果。理解上的难点：如果没有遇到end就算None。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;const char* pl[3][3] = &#123;"Glycine", "Cysteine", "START", "END", "END", "Arginine", "Serine", "DELETE", "Lysine"&#125;;int main(void)&#123; string getstr, putstr[20]; int cnt = 0, f[35] = &#123;0&#125;; cin &gt;&gt; getstr; int lg = getstr.length(); for(int i = 0; i &lt; lg; i++) &#123; //将字符转换为数字 if(getstr[i] == 'A') f[i] = 0; else if(getstr[i] == 'T') f[i] = 1; else if(getstr[i] == 'U') f[i] = 2; &#125; for(int i = 0; i &lt; lg - 1; i++) &#123; if(!strcmp(pl[f[i]][f[i + 1]], "START")) &#123; //c语言字符串不能直接比较是否相等，所以用strcmp比较 int j = i + 2; while(strcmp(pl[f[j]][f[j + 1]], "END")) &#123; if(!strcmp(pl[f[j]][f[j + 1]], "DELETE")) cnt--; else putstr[cnt++] = pl[f[j]][f[j + 1]]; j += 2; //判断完了就判断下一个序列 if(j &gt;= lg - 1) &#123; //判断是否有end结尾，如果没有就说明是无效序列 cnt = 0; break; &#125; &#125; break; &#125; &#125; if(cnt &lt;= 0) printf("None"); else &#123; for(int i = 0; i &lt; cnt; i++) &#123; cout &lt;&lt; putstr[i]; if(i != cnt - 1) cout &lt;&lt; ","; &#125; &#125; return 0;&#125; 僵尸危机传送门 思路：这题难点在于理解题意，理解了题意就很简单。 123456789101112131415161718#include&lt;cstdio&gt;int f[1000], a[1000];int main(void)&#123; int n; scanf("%d", &amp;n); f[0] = 1; a[0] = 3; int day = 0; while(a[day] &lt; n) &#123; f[day + 1] = a[day] - (f[day] % 4 ? f[day] / 4 + 1 : f[day] / 4); a[day + 1] = f[day + 1] * 3; day++; &#125; if(day &lt;= 1) printf("%d day", day + 1); //注意是day+1 else printf("%d days", day + 1); return 0;&#125; 再去明星演唱会传送门 思路：简单的dfs，然后用栈（我用的是vector来模拟栈）存储记录点座标的结构体，当到达目标座标的时候，按格式输出栈里面的所有座标，而且要分四次在四个角上使用dfs，如果角上坐了人，就输出-1，或者无法到达目标座标也输出-1，这里用flag来标志是否能到达目标座标。（由于之前刷题时，题目测试数据里面有目标座标可能也坐了人，所以要特判，此时算是到达了目标座标，不过比赛的数据我不知道有没有这种测试数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;int a[20][20], nex[4][2] = &#123;0, -1, -1, 0, 0, 1, 1, 0&#125;, n, m, ex, ey, flag = 0, book[20][20]; //a数组存储某点是否有人，next用于按照左下右上的顺序遍历，book数组用来判断是否已经走过这个点。struct node &#123; int x, y;&#125;;vector&lt;node&gt; ss;//记录已经走过的路径void dfs(int x, int y) //完全是dfs模板，&#123; if(x == ex &amp;&amp; y == ey) &#123; flag = 1; //说明从这个点可以到达目标座标 int len = ss.size(); for(int i = 0; i &lt; len; i++) &#123; printf("(%d,%d)", ss[i].x, ss[i].y); if(i != len - 1) printf("-&gt;"); &#125; printf("\n"); return ; &#125; for(int i = 0; i &lt; 4; i++) &#123; int tx = x + nex[i][0]; int ty = y + nex[i][1]; if(tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; m || book[tx][ty] || (a[tx][ty] == 1 &amp;&amp; !(tx == ex &amp;&amp; ty == ey))) continue; //这里的最后括号里面的特判是因为目标座标可能有人，也算可以到达，这是因为之前有个数据卡了我很多次。。。这个比赛的数据我不知道有没有卡。。。 book[tx][ty] = 1; node tn; tn.x = tx; tn.y = ty; ss.push_back(tn); dfs(tx, ty); ss.pop_back(); book[tx][ty] = 0; &#125;&#125;int main(void)&#123; scanf("%d %d", &amp;ex, &amp;ey); scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; int beg[4][2] = &#123;1, 1, 1, m, n, 1, n, m&#125;; for(int i = 0; i &lt; 4; i++) &#123; flag = 0; if(a[beg[i][0]][beg[i][1]] == 1) &#123; //判断角上是否有人，有人就不能走 printf("-1\n"); continue; &#125; for(int ii = 1; ii &lt;= n; ii++) &#123; for(int j = 1; j &lt;= m; j++) &#123; book[ii][j] = 0; &#125; &#125; book[beg[i][0]][beg[i][1]] = 1; node tn; tn.x = beg[i][0]; tn.y = beg[i][1]; ss.push_back(tn); dfs(beg[i][0], beg[i][1]); ss.pop_back(); book[beg[i][0]][beg[i][1]] = 0; if(flag == 0) &#123; //这个角无法到达目标座标 printf("-1\n"); &#125; &#125; return 0;&#125; 摸鱼传送门 思路：这题我是用一个结构体存储每个人的编号、随机数、对他%的人数。每当输入一个朋友关系的时候，判断谁的随机数大，然后大的那个人的 对他%的人数 减一（就是减掉他的朋友），然后把这个结构体数组按照随机数大小从小到大排序，然后根据下标计算每个人的对他%的人数，再按照编号排序，输出%他的人数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int f[200100];struct node &#123; int num, random; int bai;&#125; ss[200100];bool cmp(node a, node b)&#123; if(a.random != b.random) return a.random &lt; b.random; return a.num &lt; b.num;&#125;bool cmp1(node a, node b)&#123; return a.num &lt; b.num;&#125;int main(void)&#123; int n, k; scanf("%d %d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;ss[i].random); ss[i].num = i; ss[i].bai = 0; &#125; for(int i = 1; i &lt;= k; i++) &#123; int a, b; scanf("%d %d", &amp;a, &amp;b); if(ss[a].random &lt; ss[b].random) ss[b].bai--; else if(ss[a].random &gt; ss[b].random) ss[a].bai--; &#125; sort(ss + 1, ss + n + 1, cmp); int cnt = 0; for(int i = 2; i &lt;= n; i++) &#123; //这是重点代码，判断有几个人的随机数小于现在这个人 if(ss[i - 1].random == ss[i].random) ss[i].bai += cnt; else &#123; cnt = i - 1; ss[i].bai += cnt; &#125; &#125; /* printf("\n"); for(int i=1;i&lt;=n;i++)&#123; printf("%d",ss[i].random); if(i!=n) printf(" "); &#125; */ sort(ss + 1, ss + n + 1, cmp1); for(int i = 1; i &lt;= n; i++) &#123; printf("%d", ss[i].bai &lt; 0 ? 0 : ss[i].bai); if(i != n) printf(" "); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[题解]]></title>
    <url>%2Ffbf2b730%2F</url>
    <content type="text"><![CDATA[洛谷 p2812 回家链接 思路：直接用dfs搜索，需要注意的是当移动时，有的点只可以经过一次（起点和鼠标所在的点，防止走回头路），有的点则可以经过两次（一次是残血，一次是走到附近加了血之后）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;int flag = 0, n, m, a[10][10], hp = 6, min = 0x3f3f3f3f, sum = 0, book[10][10];int next[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;void dfs(int x, int y)&#123; if(hp == 0) return; //此时没血了,不能走了 if(a[x][y] == 4) &#123; //到达鼠标所在的点 hp = 6; book[x][y] = 1; &#125; if(a[x][y] == 3) &#123; //到达终点 flag = 1; min = sum &lt; min ? sum : min; return; &#125; int tx, ty; for(int i = 0; i &lt; 4; i++) &#123; tx = x + next[i][0]; ty = y + next[i][1]; if(a[tx][ty] == 2 || tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m || a[tx][ty] == 0 || (a[tx][ty] == 4 &amp;&amp; book[tx][ty] == 1) || book[tx][ty] == 2 ) continue; int t = hp; hp--; sum++; book[tx][ty]++; dfs(tx, ty); book[tx][ty]--; sum--; hp = t; &#125; return;&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; int x, y; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(2 == a[i][j]) &#123; x = i; y = j; &#125; &#125; &#125; dfs(x, y); if(flag == 1) printf("%d", min); else printf("-1"); return 0;&#125; 洛谷 p1443 马的遍历链接 思路：直接套模板。。。bfs。。。（虽然很水，但可以复习bfs模板。。。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;int n, m, startx, starty, a[401][401], book[401][401], next[8][2] = &#123;2, 1, 1, 2, -1, 2, -2, 1, -2, -1, -1, -2, 1, -2, 2, -1&#125;;bool judge(int x, int y)&#123; if(x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m) &#123; return false; &#125; return true;&#125;struct node &#123; int x; int y; int step;&#125; que[160001];int main(void)&#123; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;startx, &amp;starty); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; a[i][j] = -1; &#125; &#125; a[startx][starty] = 0; book[startx][starty] = 1; int head = 1, tail = 1; que[tail].x = startx; que[tail].y = starty; que[tail].step = 0; tail++; while(head &lt; tail) &#123; for(int i = 0; i &lt; 8; i++) &#123; int tx = que[head].x + next[i][0]; int ty = que[head].y + next[i][1]; if(book[tx][ty] == 1 || !judge(tx, ty) ) continue; que[tail].x = tx; que[tail].y = ty; a[tx][ty] = que[tail].step = que[head].step + 1; tail++; book[tx][ty] = 1; &#125; head++; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; printf("%-5d", a[i][j]); &#125; printf("\n"); &#125; return 0;&#125; 洛谷 p1892 团伙链接 思路：这是一个并查集的题目，需要注意的就是，敌人的敌人是朋友，所以在判断敌人时，要多弄一个把敌人的敌人合并为朋友的语句。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int n, m, f[1001], e[1001];int getf(int u)&#123; if(f[u] == u) return u; f[u] = getf(f[u]); return f[u];&#125;bool merge(int u, int v)&#123; int t1 = getf(u); int t2 = getf(v); if(t1 == t2) return false; f[v] = t1; return true;&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; f[i] = i; e[i] = 0; &#125; for(int i = 1; i &lt;= m; i++) &#123; char ch; int p, q; //scanf("%c %d %d",&amp;ch,&amp;p,&amp;q); cin &gt;&gt; ch &gt;&gt; p &gt;&gt; q; if(ch == 'F') &#123; merge(p, q); &#125; else if(ch == 'E') &#123; if(e[p] != 0) &#123; merge(e[p], q); &#125; else e[p] = q; if(e[q] != 0) &#123; merge(e[q], p); &#125; else e[q] = p; &#125; &#125; int sum = 0; for(int i = 1; i &lt;= n; i++) &#123; if(f[i] == i) sum++; &#125; printf("%d", sum); return 0;&#125; 洛谷 p2024食物链链接 思路：这题我没想到思路，通过看题解的思路来写代码。这题是种类并查集 的题目，通过将初始数组的大小置为n的倍数，然后将数组划分为若干个集合（1 ~ n , n+1 ~ 2n , … 每个集合里面有n个元素），第二个集合是第一个集合的天敌，第三个集合是第二个集合的天敌，第一个集合是第三个集合的天敌，然后通过将同类动物放在同一个集合里讨论，不同类动物（敌对）则在不同的集合里面讨论。当对动物进行合并时，要同时对不同的集合进行操作。当对输入的东西进行讨论是则只需要只需要对一组集合进行讨论就可以了。（种类并查集求的并非具体种类，而是关系！）参考的题解链接 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;int n, k, f[150001];int getf(int u) //找同类&#123; return f[u] == u ? u : f[u] = getf(f[u]);&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;k); for(int i = 1; i &lt;= n * 3; i++) f[i] = i; int a, x, y, sum = 0; for(; k; k--) &#123; scanf("%d %d %d", &amp;a, &amp;x, &amp;y); if(x &gt; n || y &gt; n) &#123; sum++; continue; &#125; if(a == 1) &#123; if(getf(x) == getf(y + n) || getf(x + n) == getf(y)) &#123; //当x和y时互相为天敌时，这个输入的语句为假 sum++; &#125; else &#123; //将x和y设置为同类(三个集合都要设置) f[getf(x)] = getf(y); f[getf(x + n)] = getf(y + n); f[getf(x + 2 * n)] = getf(y + 2 * n); &#125; &#125; else &#123; if(getf(x) == getf(y) || getf(x + n) == getf(y)) &#123; //判断是否是同类 sum++; &#125; else &#123; //将x和y设置为天敌关系 f[getf(x)] = getf(y + n); f[getf(x + n)] = getf(y + 2 * n); f[getf(x + 2 * n)] = getf(y); &#125; &#125; &#125; printf("%d", sum); return 0;&#125; 洛谷 p3371 【模板】单源最短路径（弱化版）链接 思路：这题如果用邻接矩阵会有三个MLE，原因是邻接矩阵数组过大（10000 X 10000），然后用了一些时间学习链式前向星。所以我最后ac的解法是Dijkstra+链式前向星 。还有就是用快读的方式减少运行时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#define Maxn 10001const int inf = 0x3f3f3f3f;int n, m, s, dis[Maxn], book[Maxn];int cnt = 1, head[Maxn] = &#123;0&#125;; //head用来记录以某个起点的第一条边，cnt用来记录edge的当前下标struct Edge &#123; int next;//（同一起点）下一条边的数组下标 int to;//边的终点 int w;//边的长度(权)&#125; edge[500001];void add(int u, int v, int w) //将以u为起点v为终点的边存储到链式前向星里面&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++;&#125;int read(void) //快读&#123; char ch = getchar(); int n = 0; while(ch &lt; '0' || ch &gt; '9') ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; n = (n &lt;&lt; 1) + (n &lt;&lt; 3) + ( ch &amp; 15 ); ch = getchar(); &#125; return n;&#125;int main(void)&#123; n = read(); m = read(); s = read(); for(int i = 1; i &lt;= n; i++) dis[i] = inf; dis[s] = 0; for(; m; m--) &#123; int u, v, w; u = read(); v = read(); w = read(); add(u, v, w); &#125; int t = s, min = inf; while(!book[t]) &#123; //条件为当dis存在未确定的边里面的最小边,至于原因可以看dijkstra算法 book[t] = 1; for(int i = head[t]; i; i = edge[i].next) &#123; //从某一始点的第一条边开始遍历，松弛dis数组 if(!book[edge[i].to] &amp;&amp; dis[edge[i].to] &gt; dis[t] + edge[i].w) dis[edge[i].to] = dis[t] + edge[i].w; &#125; min = inf; for(int i = 1; i &lt;= n; i++) &#123; //查看是否所有点已经松弛完成，即所有点都确定了 if(!book[i] &amp;&amp; dis[i] &lt; min) &#123; t = i; min = dis[i]; &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; if(dis[i] != inf) printf("%d ", dis[i]); else printf("2147483647 "); &#125; return 0;&#125; 洛谷 P1462 通往奥格瑞玛的道路链接 思路：这题我写了两天（改代码和学习，我太菜了）。。。题意的交费最多的最小值就是当他能到达终点时，肯定有个收费最多的点，在所有可能的路径中，收费最多的点的最小值。用dijkstra+二分来写（还要用堆优化，不然会tle。。。卡了将近一天），主要是将点权二分，然后找最短满足点权条件的最短路径，一直二分，最后找到满足条件的最小值。堆优化就是找出利用priority_queue（大佬也可以用手写最小堆）来记录dijkstra里面遍历到的点，其中要自定义一个struct cmp 来作为模板参数的第三个参数（以!cmp录入，和sort函数不同）。然后就是二分后的top（将大于top的点直接排除）要作为check函数里面部分条件的判断依据（如代码）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MAXn = 10001; //最大的点的数目const int inf = 0x3f3f3f3f;int cnt = 1, dis[MAXn], book[MAXn] = &#123;0&#125;, n, m, b, head[MAXn], f[MAXn];struct cmp &#123; //我没试直接写个cmp函数可不可以。。。 bool operator()(int &amp;a, int &amp;b) const &#123; //因为优先出列判定为!cmp，所以反向定义实现最小值优先 return dis[a] &gt; dis[b]; &#125;&#125;;void quicksort(int *p, int left, int right) //快排。。。（tle后各种优化，连sort都换了）&#123; if(left &gt; right) return; int temp = p[left]; int l = left, r = right; while(l != r) &#123; while(p[r] &gt;= temp &amp;&amp; l &lt; r) r--; while(p[l] &lt;= temp &amp;&amp; l &lt; r) l++; if(l &lt; r) &#123; int t = p[l]; p[l] = p[r]; p[r] = t; &#125; &#125; p[left] = p[l]; p[l] = temp; quicksort(p, left, l - 1); quicksort(p, l + 1, right);&#125;int read(void)&#123; int n = 0; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; n = (n &lt;&lt; 1) + (n &lt;&lt; 3) + (ch &amp; 15); ch = getchar(); &#125; return n;&#125;struct Edge &#123; int next; int to; int w;&#125; edge[2 * 50001];void add(int u, int v, int w)&#123; edge[cnt].w = w; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt++;&#125;bool check(int top)&#123; if(top &lt; f[1] || top &lt; f[n]) return false; int t; for(int i = 1; i &lt;= n; i++) &#123; dis[i] = inf; book[i] = 0; &#125; dis[1] = 0; priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; pq; //用堆记录dis里面未松弛的点里面的最小值的点 pq.push(1); while(!pq.empty()) &#123; t = pq.top(); pq.pop(); if(book[t] || top &lt; f[t]) continue; //如果已经松弛或者当前点收费大于top时 book[t] = 1; for(int i = head[t]; i; i = edge[i].next) &#123; //边的遍历，对dis松弛. if(f[edge[i].to] &lt;= top &amp;&amp; !book[edge[i].to] &amp;&amp; dis[edge[i].to] &gt; dis[t] + edge[i].w) &#123; dis[edge[i].to] = dis[t] + edge[i].w; pq.push(edge[i].to); &#125; &#125; &#125; return dis[n] &lt;= b;&#125;int main(void)&#123; n = read(); m = read(); b = read(); int c[MAXn] = &#123;0&#125;; for(int i = 1; i &lt;= n; i++) &#123; f[i] = read(); c[i] = f[i]; &#125; int u, v, w; for(int i = 1; i &lt;= m; i++) &#123; u = read(); v = read(); w = read(); if(u == v) continue; add(u, v, w); add(v, u, w); &#125; quicksort(c, 1, n); int l = 1, r = n, mid; if(!check(c[n])) &#123; //判断是否有到达终点的路径 printf("AFK\n"); return 0; &#125; int ans = c[n]; while(l &lt;= r) &#123; //对点的费用按大小进行二分 mid = (l + r) &gt;&gt; 1; if(check(c[mid])) &#123; r = mid - 1; ans = c[mid]; &#125; else l = mid + 1; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
        <tag>并查集</tag>
        <tag>单源最短路径</tag>
        <tag>dijkstra</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01迷宫]]></title>
    <url>%2Fd877abb7%2F</url>
    <content type="text"><![CDATA[01迷宫 题目链接(洛谷) 这题主要是理解题目意思，我一开始以为这题描述的是求能走的最长路径，后来wa了找不出问题，看了题解才知道原来不是求最长路径，而是求从某点能到达的所有的点的总数（包括自己）。理解了题意就容易了，我用的方法是先dfs+染色，再根据输入的位置来输出结果。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;int a[1001][1001], book[1001][1001], f[1000001], n, m; //数组a保存地图，数组book记录染色情况，数组f记录某个颜色总大小int next[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;; //前进的方向int read(void) //快读&#123; char ch = getchar(); while(ch != '1' &amp;&amp; ch != '0') ch = getchar(); return ch &amp; 1;&#125;void dfs(int aa, int bb, int color) //aa和bb为位置，color为当前染色的颜色&#123; int tx, ty; for(int i = 0; i &lt; 4; i++) &#123; tx = aa + next[i][0]; ty = bb + next[i][1]; if(tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; n || book[tx][ty] || a[tx][ty] == a[aa][bb]) continue; f[color]++; book[tx][ty] = color; dfs(tx, ty, color); &#125;&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; a[i][j] = read(); &#125; &#125; int c = 1; //颜色 for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(!book[i][j]) &#123;//当前点未经过染色 f[c] = 1; //把当前点也记录进去 book[i][j] = c; //开始染色 dfs(i, j, c++); &#125; &#125; &#125; int x, y; for(int i = 1; i &lt;= m; i++) &#123; //读入点的坐标 scanf("%d %d", &amp;x, &amp;y); printf("%d", f[book[x][y]]); //输出当前颜色占据的总大小，即当前点能到达的所有的点的数目 if(i != m) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂和矩阵的快速幂]]></title>
    <url>%2F6b81fe2c%2F</url>
    <content type="text"><![CDATA[快速幂和矩阵的快速幂求an的值，可以一个一个乘起来，也可以转化为其他多个数想乘，例如an=an/2* an/2=an/3* an/3* an/3=…，当n的值非常大的时候，这两种求法效率明显不够高，所以就有大佬想出了快速幂的算法，快速幂算法的主要代码如下： 12345678int res=1;//res为记录结果的变量void pow(int a,int n)&#123; while(n)&#123; if(n&amp;1) res*=a; n&gt;&gt;=1; a*=a; &#125;&#125; 如果看代码无法理解（反正我开始直接看代码是没理解），则可以结合例子看代码： 276=201001100B(2进制)=2100B* 21000B* 21000000B=24* 28 * 264 而矩阵的快速幂算法则差不多是一样的，下面为题目贴图和代码： 方阵的阶乘 描述 给定一个N阶方阵A，输出A的M次幂对10000求余的值（M是非负整数） 输入 第一行是一个正整数N、M（1&lt;=N&lt;=50, 0&lt;=M&lt;=7.5e18），表示方阵A的阶数和要求的幂数 接下来N行，每行N个绝对值不超过10的非负整数，描述方阵A的值 输出 输出共N行，每行N个整数，表示A的M次幂所对应的方阵对10000求余数。相邻的数之间用一个空格隔开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;int a[51][51], b[51][51]; //a为当前输入的矩阵，b为记录结果的矩阵int n;void cheng(int x[][51], int y[][51]) //x*=y(x和y为矩阵)&#123; int sum = 0, z[51][51] = &#123;0&#125;; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; for(int k = 1; k &lt;= n; k++) &#123; sum += x[i][k] * y[k][j]; &#125; z[i][j] = sum % 10000; sum = 0; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; x[i][j] = z[i][j]; &#125; &#125;&#125;void mi(int x[][51], long long int m)&#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(i == j) b[i][j] = 1; //注意记录结果的数组初始值设置 &#125; &#125; while(m) &#123; //主要代码 if(m &amp; 1) &#123; cheng(b, x); &#125; m &gt;&gt;= 1; cheng(x, x); &#125;&#125;int main(void)&#123; long long int m; scanf("%d %lld", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; mi(a, m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; printf("%d", b[i][j]); if(j != n) printf(" "); &#125; if(i != n) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[To Fill or Not to Fill]]></title>
    <url>%2F21fcb834%2F</url>
    <content type="text"><![CDATA[题目：To Fill or Not to Fill` 传送门 这题主要是贪心，然后就是细节了，首先，输入的数字除了N以外都要用double（不能用float，不然有大的数据会通不过），具体思路是：1.当加油站之间的距离或与终点的距离大于满油时能行驶的最大距离时，要输出最大距离。2.在加油站的一定距离以内，第一个价格比当前加油站价格低的加油站为下一个需要直接到达的加油站。3.若在加油站以内没有比当前加油站价格低的加油站，则加满油后直接去最价格相对最低的加油站。4.若当前加油站能直接到达终点，且范围内没有价格更低的加油站时，直接到达终点（即使是最后一个加油站也是如此判断）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int N, cur, minn;double Cmax, D, Davg, oil = 0.0;const double inf = 0x3f3f3f3f;struct ss &#123; double m; double p;&#125; qq[510];bool cmp(ss a, ss b)&#123; return a.p &lt; b.p;&#125;int find(void)&#123; minn = cur; double min = inf; if(qq[cur + 1].p - qq[cur].p &gt; Cmax * Davg) return -1; int i; for(i = cur + 1; qq[i].p - qq[cur].p &lt;= Cmax * Davg &amp;&amp; i &lt; N; i++) &#123; if(qq[i].m &lt; qq[cur].m) &#123; minn = i; break; &#125; &#125; if(minn == cur) &#123; for(int j = cur + 1; qq[j].p - qq[cur].p &lt;= Cmax * Davg &amp;&amp; j &lt; N; j++) &#123; if(qq[j].m &lt; min) &#123; min = qq[j].m; minn = j; &#125; &#125; return cur; &#125; else &#123; return minn; &#125;&#125;int main(void)&#123; scanf("%lf %lf %lf %d", &amp;Cmax, &amp;D, &amp;Davg, &amp;N); cur = 0; for(int i = 0; i &lt; N; i++) &#123; scanf("%lf %lf", &amp;qq[i].m, &amp;qq[i].p); &#125; qq[N].p = D; //printf("%d\n",qq[0].p); stable_sort(qq, qq + N, cmp); //printf("%d\n",qq[0].p); if(qq[0].p != 0) &#123; printf("The maximum travel distance = 0.00"); return 0; &#125; double maxm = 0.0, maxp = 0; int r; bool flag = 1; cur = 0; while(flag) &#123; r = find(); //printf("%d\n",r); //printf("--%d\n",cur); if(r == -1) &#123; maxp = qq[cur].p + Cmax * Davg; flag = 0; break; &#125; else if(r == cur) &#123; if(qq[cur].p + Cmax * Davg &gt;= D) &#123; maxm += qq[cur].m * ((D - qq[cur].p) / Davg - oil); break; &#125; maxm += (Cmax - oil) * qq[cur].m; oil = Cmax - (qq[minn].p - qq[cur].p) / Davg; cur = minn; &#125; else &#123; maxm += ((qq[r].p - qq[cur].p) / Davg - oil) * qq[cur].m; oil = 0.0; cur = r; &#125; &#125; if(flag == 0) &#123; printf("The maximum travel distance = %.2lf", maxp); &#125; else &#123; printf("%.2lf", maxm); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
