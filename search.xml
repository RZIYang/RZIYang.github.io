<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机通信与网络-笔记]]></title>
    <url>%2F8847b510%2F</url>
    <content type="text"><![CDATA[文章概要：这篇笔记主要是为了加强记忆，所以就基本上是照搬书上的内容。 第一章 概述主要内容： 互联网边缘部分和核心部分的作用，其中包含分组交换的概念。 计算机网络的性能指标。 计算机网络分层次的体系结构，包含协议和服务的概念。 计算机网络在信息时代的作用​ 21世纪的一些重要特征是数字化、网络化和信息化，这是一个以网络为核心的信息时代 计算机网络（网络）：由若干节点（node，准确说是结点）和连接这些节点的链路（link）组成。 互连网（internet）：网络之间通过路由器互连起来（一个更大的网络） 互联网（Internet，有时也称为因特网）：全球最大的互连网（internet），重要特性是连通性和共享。 连通性：互联网使用户之间，不管相距多远，都可以非常便捷经济地交换各种信息。 共享：指资源共享，可以是信息共享、软件共享和硬件共享。例如服务器上存储的电子文档可供用户有偿或无偿地读取或下载。 基本概念：网络把许多计算机连接起来，互连网把许多网络通过路由器连接起来。其中，世界上最大的互连网（internet）是互联网（Internet）。与网络相连的计算机通常被称为主机（host）。 ​注意：网络的互连并不是仅仅简单地将计算机物理的连接起来，还要在计算机上安装许多使计算机能交换信息的软件（我们所说的互连就暗指指已经安装了必要的软件）。 互联网发展历史及特点（三个阶段） 第一阶段：由单个网络ARPANET向互连网发展。 第二阶段：建成了三级结构的互联网（主干网、地区网和校园网或企业网）。 第三阶段：形成了多层次的ISP（互联网服务提供者）结构的互联网。 ​根据服务的覆盖面积大小以及所拥有的IP地址数目的不同，ISP也分为不同层次的ISP，分别是主干ISP、地区ISP和本地ISP。 主干ISP：由专门的公司创建和维持。服务面积最大（一般都能够覆盖国家范围）,并且还拥有告诉主干网。 地区ISP：一些较小的ISP，地区ISP通过一个或多个主干ISP连接起来。 本地ISP：给用户（端用户，强调是末端的用户）提供直接的服务，可以连接到地区ISP，也可以连接主干ISP。本地ISP可以是提供互联网服务的公司，也可以是向雇员提供服务的企业，或者是学院或大学。 互联网交换点（IXP）：允许两个网络直接相连并交换分组，并不需要第三个网络转发分组。 互联网的拓扑结构虽然很复杂,并且地理上覆盖了全球，但从其工作方式上看，可以划分为以下两大块： 边缘部分：由所有连接在互联网上的主机组成。这部份是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。 核心部分：由大量网咯和连接这些网络的路由器组成。这部份给边缘部分提供服务（提供连通性和交换）。 互联网的边缘部分就是连接在互联网上的所有主机，这些主机也称为端系统（end system）。端系统在功能上可能有很大的差别，小的端系统可能是个人电脑、手机和摄像头，大的端系统可能是大型计算机。拥有者可以是个人，可以是企业或学校，也可以是ISP。 注意：我们所说的“主机A和主机B进行通信”指的是运行在A上的某个程序和运行在B上的某个程序进行通信，也就是“主机A上某个进程和主机B上某个进程进行通信”，可以简称为“计算机之间通信”。 在端系统之间的通信可以分为两大类：客户-服务器方式（C/S方式）和对等方式（P2P方式）。 客户（client）-服务器（server）方式：这种方式是互联网最常用的，也是传统的方式。这里的客户和服务器指的是通信中所涉及的两个应用进程。客户向服务器发送服务请求，服务器向客户提供服务。客户是服务请求方，服务器是服务提供方。 客户程序的特点 客户程序必须知道服务器程序的地址。 不需要特殊的硬件和复杂的操作系统。 服务器程序的特点 是专门提供某种服务的程序，可同时处理多个远程或本地客户的请求。 系统启动后一直运行着，被动等待请求，不需要知道客户程序的地址。 一般有强大的硬件和高级的操作系统支持。 对等连接方式（peer-to-peer，简写P2P）：两台主机在通信时并不区分哪一个是服务请求方，哪一个是服务提供方。自要两台主机都安装了对等连接软件，他们就可以进行平等的、对等连接通信。 注意：上面所说的客户和服务器都指的是计算机进程（软件）。使用计算机的人是计算机的用户（user），而不是客户（client）。在许多国外文献中，经常把运行客户程序的机器称为client（这时应该译为“客户端”或“客户机”），把运行服务器程序的机器称为server（这时译为“服务器端”或“服务器”） 互联网的核心部分起特殊作用的是路由器（router），它是一种专用计算机（但不是叫做主机），它是实现分组交换的（packet switching）的关键构建，任务是转发收到的分组。下面介绍电路交换和分组交换的特点。 电路交换：在通话期间，通话的两个用户一直占用端到端的通信资源。且传输效率低。 分组交换：采用存储转发技术。将报文（message）划分为更小的数据段，然后数据段加上必要的控制信息组成的首部（header）就构成一个分组（packet）。分组又称为“包”，分组的首部称为“包头”。 处于网络边缘的主机和网络核心部分的路由器都是计算机，但它们的作用不一样。 主机为用户进行信息处理，可以通过网络与其他主机交换信息。 路由器用来转发分组，进行分组交换。 分组交换的主要优点如下： 优点 所采用的手段 高效 在分组传输过程中动态分配传输宽带，对通信链路是逐段占用 灵活 为每一个分组独立地选择最合适的转发路由 迅速 以分组作为传输单位，可以不先建立连接就能向其他主机发送分组 可靠 保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性 分组交换也带来一些新的问题。例如，分组在路由器存储转发是需要排队，这就会造成一定的时延。此外，由于分组交换不像电路交换那样通过建立连接来保证通信时所需的各种资源，因此无法确保端到端所需的带宽。还有就是分组必须携带的控制信息也造成了一定的开销（overhead）。 接下来介绍三种交换方式在数据传送阶段的主要特点： 电路交换——整个报文的比特流连续地从源点直达终点，就像在一个管道中传送。 报文交换——整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。 分组交换——单个分组（报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。 若连续传输大量数据，且传输时间远大于建立连接时间，则电路交换的传输速率最快。报文交换和分组交换在传输突发数据时可以提高整个网络的信道（channel）利用率。 计算机网络的分类 按照网络的作用范围进行分类 广域网WAN（Wide Area Network），有时也称为远程网（long haul network） 城域网MAN（Metropolitan Area Network） 局域网LAN（Local Area Network） 个人局域网PAN（Personal Area Network） 按照网络使用者进行分类 共用网（public network） 专用网（private network） 用来把用户接入到互联网的网络 接入网AN（Access Network），又称为本地接入网或居民接入网 计算机网络的性能指标 速率（bit/s，比特每秒）（或b/s，bps即bit per second），又称为数据率（data rate）或比特率（bit rate） 1k=10^3 带宽（bandwidth） 指某个信号具有的频带宽度，这种带宽的单位是赫兹 在计算机网络中，带宽表示网络中某通道传送数据的能力，即单位时间内某信道所能通过的“最高数据率”，单位是数据率的单位，即bit/s。 吞吐量（throughput）表示单位时间内通过某个网络的实际的数据量。吞吐量受网络的带宽和额定速率的限制。单位是bit/s。 时延（delay或latency）指数据（报文或分组或比特）从网络的一端到另一端所需的时间。有时称为延迟或迟延。网络的时延由以下几部分组成： 发送时延（transmission delay）：是主机或路由器发送数据帧所需要的时间。从发送第一个数据帧开始到发送完最后一个数据帧的时间。发送时延也称为传输时延。$$发送时延=\frac{数据帧长度（bit）}{发送速率（bit/s）}$$ 传播时延（propagation delay）是电磁波在信道中传播一定距离花费的时间。$$传播时延=\frac{信道长度（m）}{电磁波在信道中的传播速率（m/s）}$$ 处理时延 主机或路由器收到分组时要花费一定时间进行处理，例如分析分组的首部、进行差错检验或查找适当的路由等，这就产生了处理时延。 排队时延 分组进入路由器后要进入排队队列等待处理。排队时延的长短取决于网络当时的通信量。当网络通信量很大时会发生队列溢出，使分组丢失，此时排队时延为无穷大。综上，数据的总时延就是以上四种时延之和$$总时延=发送时延+传播时延+处理时延+排队时延$$一般情况下小时延网络优于大时延网络。在某些情况下，一个低速率小时延的网络要优于高速率大时延的网络。注意：对于高速网络的链路，提高的仅仅是发送速率而不是传播速率。所以高速网络的链路上比特并不会传送的更快。提高发送速率仅仅是减少发送时延。还有就是发送时延的意思是每秒发送多少个比特，指某个点的发送速率，而传播时延的意思是每秒传送多少公里，指比特在链路上的传播速率。 时延带宽积 把传播时延和带宽相乘，就得到另一个度量：传播时延带宽积，即$时延带宽积=传播时延\times带宽$ ，链路的时延带宽积又称为以比特为单位的链路长度。 往返时间RTT（Round-Trip Time）：从A向B发送数据，A收到B发送的收到信息的信号的时间。使用RTT计算有效数据率的公式为：$$有效数据率=\frac{数据长度}{发送时间+RTT}$$ 利用率：有信道利用率和网络利用率。注意：信道或网络的利用率过高会产生非常大的时延。 信道利用率：指某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道利用率为0。 网络利用率：全网络的信道利用率的加权平均值。 计算机网络的非性能指标 费用：一般情况，网络的速率越高，价格也越高。 质量：网络的质量取决于所有构件的质量，以及这些构件是怎样组成网络的。 标准化：网络的硬件和软件的设计可以按照国际标准，也可以遵循特定的专用网络标准。最好采用国际标准，可以得到更好的互操作性。 可靠性：可靠性与网络的性能和质量有密切关系。高速网络可靠性不一定很差，但高速网络要可靠地运行，则往往更加困难，同时所需的费用也会比较高。 可扩展性和可升级性 易于管理和维护 网络协议主要由以下三要素组成： 语法，即数据与控制信息的结构或格式。 语义，即需要发出何种控制信息，完成何种动作以及作出何种响应。 同步，即时间实现顺序的详细说明。 对于复杂的计算机网络协议，其结构应该是层次式的，分层的好处有： 各层之间是独立的。某一层不需要知道它的下层是如何实现的，仅仅需要知道层与层接口所提供的服务就可以了。而且每一层只实现一种相对独立的功能，因而将一个复杂的问题划分为若干个容易处理的小问题。 灵活性好。如果任何一层发生了改变，只需要保证层之间的接口不变就能保证其它各层不受到影响。 结构上可以分割开。各层可以用最适合的不同的技术实现。 易于实现和维护。实现和调试一个复杂而又庞大的系统时易于处理，因为已经分为若干个小的系统。 能够促进标准化工作。因为每一层的功能和所提供的服务已经有了精确的说明。 实现时，各层所要完成的功能主要有以下几个（可以只包含一个，也可以包含多个）： 差错控制，使得相应层次对等方的通信更加可靠。 流量控制，发送方的发送速率必须使得接收方能够来得及接收，不能太快。 分段和重装，发送端将要发送的数据划分为更小的单位，在接收端进行还原 复用和分用，发送端几个高层会话共用一条底层的连接，在接收端进行分用。 连接建立和释放，交换数据前建立一条逻辑连接，数据传送结束后释放连接。 OSI的七层协议体系结构的概念清楚理论也比较完整，但它即复杂又不实用。TCP/IP体系结构则不同，它现在得到了广泛的应用。它们的具体特征如图：（注：五层协议的体系结构只是为介绍网络原理而设计的，实际上还是TCP/IP四层体系结构）对于五层协议的体系结构，下面自上而下地、简要介绍各层的主要功能： 应用层（application layer） 应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。对于不同的网络应用需要不同的应用层协议。例如：域名系统DNS、支持万维网应用的HTTP协议、支持电子邮件的SMTP协议。应用层交互的数据单元称为报文（message）。 运输层（transport layer） 运输层的任务是负责向两台主机中进程之间的通信提供通用的数据传输服务。使得多个应用可以使用同一个运输层服务。 运输层有复用和分用的功能： 复用：指多个应用进程可以同时使用运输层的服务 分用：指运输层把收到的信息分别交给不同的应用进程 运输层主要有以下两种协议： 传输控制协议TCP（Transmission Control Protocol）：提供面向链接的、可靠的数据传输协议，其数据传输单位是报文段（segment）。 用户数据报协议UDP（User Datagram Protocol）：提供无链接的、尽最大努力（best-effort）的数据传输服务（不保证数据传输的可靠性），其数据传输单位是用户数据报。 网络层（newwork layer） 网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装为分组或包进行传送。在TCP/IP体系中，网络层使用IP协议，所以分组也叫做IP数据报或数据报。此外，无论哪一层传送的数据单元，都可以笼统地用“分组”来表示。 网络层的另一个任务是寻找合适的路由，使源主机运输层传送下来的分组能够通过网络中的路由器找到目的主机 互联网使用的网络层协议是无连接的网际协议IP（Internet Protocol）和多种路由选择协议。网络层也称为网际层或IP层。 数据链路层（data link layer，也称为链路层） 在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧（framing），在两个相邻结点的链路上传送帧（frame）。每一帧包括数据和必要的控制信息（如控制信息、地址信息、差错控制等）。数据链路层收到一个帧后，就可从中提取出数据部分，上交给网络层。控制信息可以检测所收到的帧是否有差错，如果有差错就丢弃出差错的帧，如果要改正差错，就需要可靠的传输协议来纠正出现的差错，这种操作会使数据链路层的协议更加复杂。 物理层（physical layer） 物理层传输的数据单位是比特（bit）。发送方发送0时，接收方应该收到0，而不是1。因此物理层要考虑用多大的电压表示0，多大电压表示1，以及接收方如何识别发送方发送的比特（bit）。物理层还要确定链接电缆的插头应该有多少根引脚，以及引脚如何链接。但是，解释比特（bit）代表的意思，就不是物理层应该考虑的。而且，传输信息所利用的媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内，而在物理层下面，所以有人将物理层下面称为第0层。 在互联网所使用的各种协议中，最重要和最为著名的协议是TCP协议和IP协议,现在人们所提到的TCP/IP协议并不指单单两个具体协议，而是指TCP/IP协议族（protocol suite）。下图为数据在各层之间简单的传递过程： 实体、协议、服务和服务访问点 实体（entity）：表示任何可发送和接收信息的硬件或软件进程。 协议（protocol）：指控制两个对等实体或多个实体进行通信的规则的集合。 服务：在协议的控制下，两个对等实体间的通信使得能够向上一层提供服务。要实现本层协议，还要使用下一层提供的服务。 服务访问点SAP（Service Access Point）：指在同一个系统中相邻两层的实体进行交互（交换信息）的地方。（注意：这种层间接口和硬件接口并不一样） 要清楚，协议和服务在概念上是很不一样的： 协议的实现保证能向上一层提供服务，使用本层服务的实体只能看见服务，而无法看见本层的协议。 协议是“水平的”，协议是控制对等实体之间通信的规则；服务是“垂直的”，服务是由下层向上层通过层间接口提供的。 另外，并非在一个层内完成的所有功能都称为服务，只有那些能被高一层“看得见”的功能才是服务。上层要使用下层提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为服务原语。 OSI把层与层之间交换的数据单位称为服务数据单元SDU（Service Data Unit），它可以与PDU不一样,例如，可以多个SDU合成一个PDU，也可以一个PDU划分为多个SDU。注意：协议必须事先把所有的不利条件都考虑到，不能假定一切都是非常正常的和理想的。 第二章 物理层本章重要内容： 物理层任务 几种常用的信道复用技术 几种常用的宽带复用技术，主要是ADSL和FTTx。 物理层协议也称为物理层规程（procedure）。物理层的主要任务是：确定与传输媒体的接口有关的一些特性，即： 机械特性：指明接口的接线器的形状和尺寸、引脚数目和排列、固定和锁定装置，等。平时常见的各种规格的接插件都有严格的标准化的规定。 电气特性：指明接口电缆的各条线上出现的电压范围。 功能特性：指明某条线上出现某一电平的电压的意义。 过程特性：指明对于不同功能的各种可能事件的出现顺序。 数据在计算机内多采用并行传输方式，但数据在同行线路（传输媒体）上的传输方式多是串行传输（出于经济上的考虑），即逐个比特按照时间顺序传输，因粗物理层需要完成传输方式的转换。由于具体的物理层协议种类过多，学习物理层时应该把重心放在掌握基本概念上。 一个数据通信系统包括三部分： 源系统（或发送端、发送方），包括： 源点（source，又称为源站或信源）：产生要传输的数据 发送器：源点产生的比特流要通过发送器编码后才能在传输器中进行传输（典型的发送器就是调制器，现在很多计算机都配置调制解调器，所以计算机外部看不见调制器和解调器） 传输系统（或传输网络） 目的系统（或接收端、接收方） 接收器：接收传输系统传送过来的信号，并转化为目的设备能够处理的信息。 终点（destination，又称为目的站或信宿）：接收从接收器发送过来的比特流。 下面介绍常用术语： 消息（message）：如语音、图像、文字、视频等都是消息。 数据（data）：运送消息的实体，是使用特定方式表示的信息 信号（signal）：是数据的电气或电磁表现。根据信号中代表消息的参数的取值不同，可分为两大类： 模拟信号（或连续信号）：代表消息的参数的取值是连续的。 数字信号（或离散信号）：代表消息的参数的取值是离散的。 码元：在使用时间域（或时域）的波形表示数字信号时，代表不同离散数值的基本波形就是码元，在使用二进制编码时，只有两种不同的码元，一种代表0状态，一种代表1状态。 有关信道（channel）的几个基本概念：信道指向某个方向传递信息的媒体，因此一条通信电路往往包含一条发送信道和一条接收信道 。从通信双方信息交互的方式来看，可以有以下3种基本方式： 单向通信（或单工通信）：只能有一个方向的通信，不能反向通信，例如无线电广播、有线电广播和电视广播。 双向交替通信（或半双工通信）：通信的双方都可以发送信息，但不能双方同时发送信息（或接收信息）。 双向同时通信（或全双工通信）：通信的双方都可以发送信息，且可以双方同时发送信息。 单向通信只需要一条信道，双向交替通信和双向同时通信都需要两条信道。双向同时通信的传输效率最高。注意：有时人们使用“单工”这个名词表示“双向交替通信”，如常说的“单工电台”就是如此。 基带信号（基本频带信号）：来自信源的信号。基带信号通常包含较多的低频部分甚至直流部分，很多信道不能传送这种低频分量或直流分量，为了解决这问题，就必须对基带信号进行调制（modulation）。调制分为两大类： 基带调制：也称为编码（coding），仅仅对基带信号的波形进行变换，使其能和信道特性相适应。把数字信号转换为另一种形式的数字信号。 带通调制：有时称为载波调制，需要使用载波（carrier）进行调制，把基带信号的频段搬移到较高的频段，并转换为模拟信号。通过载波调制后的信号称为带通信号。 常用编码方式： 不归零制：正电平代表1，负电平代表0。 归零制：正脉冲代表1,负脉冲代表0。 曼彻斯特编码：位周期中心的向上跳变代表0，向下跳变代表1，但也可以反过来定义。 差分曼彻斯特编码：在每一位的中心始终都有跳变。位开始边界有跳变代表0，位开始边界没有跳变代表1。下图为示意图：从信号波形可以看出，曼彻斯特（manchester）编码产生的信号频率比不归零制高。从自同步能力来看，不归零制不能从信号波形本身提取时钟频率（这叫做没有自同步能力），而曼彻斯特编码有自同步能力。 基本的带通调制方法： 调幅（AM）：载波的振幅随基带数字信号而变化，例如：0和1分别表示无载波和有载波输出。 调频（FM）：载波的频率随基带数字信号而变化，例如：0和1分别表示频率为f1和f2。 调相（PM）：载波的初始相位随基带数字信号而变化，例如：0和1分别表示相位0度和180度。 为了达到更高的信息传输效率，必须采用技术上更为复杂的多元制的振幅相位混合调制方法，例如：正交振幅调制QAM（Quadrature Amplitude Modulation）。下图为三种带通调制方法： 限制码元在信道上的传输速率的因素有以下两个： 信道能够通过的频率范围 在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决（即识别）称为不可能。 信噪比 信噪比是指信号的平均功率和噪声的平均功率的比值，常记为：S/N，并以分贝（dB）作为度量单位。即$信噪比(dB)=10\log_{10}(S/N)（dB）$ 香农公式：信道的极限信息传输速率C是$$C=W\log_2(1+S/N) (bit/s)$$其中W为信道的带宽（以Hz为单位），S为信道内所传信号的平均功率， N为信道内部的高斯噪声功率。 物理层下面的传输媒体 导引型传输媒体：电磁波被导引沿着固体媒体（铜线或光纤）传播 双绞线：也称为双扭线，最古老最常用的传输媒体，把两根相互绝缘的铜导线并排放在一起，然后用规则的方法绞合（twist）起来。从用户电话机到交换机的双绞线称为用户线或用户环路（subscriber loop）。如果在双绞线外面加上一层用金属丝编织而成的屏蔽层，这则是屏蔽双绞线（STP，Shielded Twisted Pair），价格比无屏蔽双绞线（UTP，Unshielded Twisted Pair）贵一些。 同轴电缆： 非导引型传输媒体：指自由空间，在非导引型传输媒体中电磁波的传输称为无线电。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机通信与网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 2020/1/18]]></title>
    <url>%2F5bd2a8c1%2F</url>
    <content type="text"><![CDATA[1039 Course List for Student (25point(s))传送门 题意：输入报名某门课程（以数字为编号）的学生的名字（以三个字母加一个数字为编号），按名字字母序输出每个人名以及对应的报的课程数目及课程。 思路：用unordered_map&lt;string, vector&lt;int&gt; &gt;来存储每个人名对应的课程（unordered_map的key不会进行排序，是通过hash来直接查找元素的，时间复杂度为O(1)，所以节省了时间，map用了红黑树，查找元素时的时间复杂度为O( log(n)））这题我用map时TLE了，而用unordered_map就过了。还有就是，这题如果用scanf和printf来代替cin和cout也可以节省时间，或者用char*代替string。有兴趣的可以把时间改的更少。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;unordered_map&gt;#include&lt;algorithm&gt;using namespace std;unordered_map&lt;string, vector&lt;int&gt; &gt; student;//记录学生姓名对应所选的课程vector&lt;string&gt; name;//记录学生姓名int n, k;//n为学生个数，k为课程总数vector&lt;int&gt; vt;//用于临时存放某个学生所选的课程int main(void)&#123; name.reserve(40001);//这个函数的用法可以去搜一下，有的地方这个函数不可或缺 vt.reserve(2501); cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= k; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; string str; for(int j = 1; j &lt;= b; j++) &#123; cin &gt;&gt; str; student[str].push_back(a); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; string na; cin &gt;&gt; na; name.push_back(na); &#125; vector&lt;string&gt;::iterator it; for(it = name.begin(); it != name.end(); it++) &#123; if(student.find(*it) == student.end()) &#123;//当没有找到对应的key时，返回unordered_map::end()，这和map是一样的 cout &lt;&lt; *it &lt;&lt; " 0" &lt;&lt; endl; &#125; else &#123; vt = student[*it]; sort(vt.begin(), vt.end()); cout &lt;&lt; *it &lt;&lt; " " &lt;&lt; vt.size(); vector&lt;int&gt;::iterator itt; for(itt = vt.begin(); itt != vt.end(); itt++) &#123; cout &lt;&lt; " " &lt;&lt; *itt; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 1047 Student List for Course传送门 题意：这题的输入输出和上面那题的输入输出正好相反，输入学生所选的课程，输出选择课程的人名。 思路：正常地使用vector构建二维数组就可以了，这题一开始我用cin和cout还有string超时了，然后我改成scanf和printf还有char*之后就ac了。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;vector&lt;vector&lt;char*&gt; &gt; name;bool cmp(char* a,char *b)&#123; return strcmp(a,b)&lt;0;//按照姓名的字母序排序，不能直接比较&#125;int main(void)&#123; int n, k; //cin &gt;&gt; n &gt;&gt; k; scanf("%d %d",&amp;n,&amp;k); name.resize(k + 1);//这个是构建二维数组时必须的东西，不然报错 for(int i = 1; i &lt;= k; i++) &#123; name[i].reserve(n); &#125; int x; for(int i = 1; i &lt;= n; i++) &#123; //cin &gt;&gt; str &gt;&gt; x; char* str=new char[5]; scanf("%s %d",str,&amp;x); int y; for(int j = 1; j &lt;= x; j++) &#123; //cin &gt;&gt; y; scanf("%d",&amp;y); name[y].push_back(str); &#125; &#125; for(int i = 1; i &lt;= k; i++) &#123; sort(name[i].begin(), name[i].end(),cmp); //cout &lt;&lt; i &lt;&lt; " " &lt;&lt; name[i].size() &lt;&lt; endl; printf("%d %d\n",i,name[i].size()); for(vector&lt;char*&gt;::iterator it = name[i].begin(); it != name[i].end(); it++) &#123; //cout &lt;&lt; *it &lt;&lt; endl; printf("%s\n",*it); &#125; &#125; return 0;&#125; 1100 Mars Numbers传送门 题意：将10进制的数字转换为13进制，然后转换为“火星语”输出，或者输入“火星语”，转换为10进制的数字。 思路：构建map时我没有用string，而是用const char*，所以比较麻烦。当const char*作为key时，map模板第三个参数必须要有，用来排序时的比较。否则会用地址来比较，然后不知道为什么无法使用const char*类型的变量（例如const char* s;）来进行访问，只能使用常量（例如&quot;tret&quot;），这个有兴趣的可以自己搜一下。还有就是13的结果不是tam tret 而是tam。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;cstring&gt;using namespace std;struct cmp &#123;//这是必须要有的，不然无法正常使用map bool operator()(const char *a, const char *b) &#123; return strcmp(a, b) &lt; 0; &#125;&#125;;map&lt;const char*, int, cmp&gt; low;//注意模板的第三个参数map&lt;int, const char*&gt; hlow, hhigh;int charToInt(char *s)//将字符串转换为数字&#123; int len = strlen(s), ans = 0, ii = 1; for(int i = len - 1; i &gt;= 0; i--) &#123; ans += (s[i] - '0') * ii; ii *= 10; &#125; return ans;&#125;int main(void)&#123; low["tret"] = 0; low["jan"] = 1; low["tam"] = 13; low["feb"] = 2; low["hel"] = 26; low["mar"] = 3; low["maa"] = 39; low["apr"] = 4; low["huh"] = 52; low["may"] = 5; low["tou"] = 65; low["jun"] = 6; low["kes"] = 78; low["jly"] = 7; low["hei"] = 91; low["aug"] = 8; low["elo"] = 104; low["sep"] = 9; low["syy"] = 117; low["oct"] = 10; low["lok"] = 130; low["nov"] = 11; low["mer"] = 143; low["dec"] = 12; low["jou"] = 156; hlow[0] = "tret"; hlow[1] = "jan"; hhigh[1] = "tam"; hlow[2] = "feb"; hhigh[2] = "hel"; hlow[3] = "mar"; hhigh[3] = "maa"; hlow[4] = "apr"; hhigh[4] = "huh"; hlow[5] = "may"; hhigh[5] = "tou"; hlow[6] = "jun"; hhigh[6] = "kes"; hlow[7] = "jly"; hhigh[7] = "hei"; hlow[8] = "aug"; hhigh[8] = "elo"; hlow[9] = "sep"; hhigh[9] = "syy"; hlow[10] = "oct"; hhigh[10] = "lok"; hlow[11] = "nov"; hhigh[11] = "mer"; hlow[12] = "dec"; hhigh[12] = "jou"; int n; scanf("%d", &amp;n); getchar(); for(int i = 1; i &lt;= n; i++) &#123; char ch; char s1[4] = &#123;0&#125;, s2[4] = &#123;0&#125;; int ii = 0; char *s = s1; while((ch = getchar()) != '\n') &#123; if(ch != ' ') s[ii++] = ch; else &#123; s = s2; ii = 0; &#125; &#125; if(s1[0] &gt;= '0' &amp;&amp; s1[0] &lt;= '9') &#123; int ans = charToInt(s1); int t1 = ans % 13; ans -= t1; if(ans == 0) &#123; printf("%s\n", hlow[t1]); &#125; else if(t1 == 0) &#123; ans /= 13; printf("%s\n", hhigh[ans]); &#125; else &#123; ans /= 13; printf("%s %s\n", hhigh[ans], hlow[t1]); &#125; &#125; else &#123; if(strlen(s2) == 0) &#123; const char *ss1 = s1; printf("%d\n", low[ss1]); &#125; else &#123; const char *ss1 = s1; const char *ss2 = s2; printf("%d\n", low[ss2] + low[ss1]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019/12/21 题解]]></title>
    <url>%2Fbc1a9440%2F</url>
    <content type="text"><![CDATA[火星上的生命传送门 思路：这题我是用模拟，将A T U变为0 1 2，然后弄个3*3的二维数组，正好对应九个字符串，然后就是将输入的字符串转换为int数组，遍历得到结果。理解上的难点：如果没有遇到end就算None。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;const char* pl[3][3] = &#123;"Glycine", "Cysteine", "START", "END", "END", "Arginine", "Serine", "DELETE", "Lysine"&#125;;int main(void)&#123; string getstr, putstr[20]; int cnt = 0, f[35] = &#123;0&#125;; cin &gt;&gt; getstr; int lg = getstr.length(); for(int i = 0; i &lt; lg; i++) &#123; //将字符转换为数字 if(getstr[i] == 'A') f[i] = 0; else if(getstr[i] == 'T') f[i] = 1; else if(getstr[i] == 'U') f[i] = 2; &#125; for(int i = 0; i &lt; lg - 1; i++) &#123; if(!strcmp(pl[f[i]][f[i + 1]], "START")) &#123; //c语言字符串不能直接比较是否相等，所以用strcmp比较 int j = i + 2; while(strcmp(pl[f[j]][f[j + 1]], "END")) &#123; if(!strcmp(pl[f[j]][f[j + 1]], "DELETE")) cnt--; else putstr[cnt++] = pl[f[j]][f[j + 1]]; j += 2; //判断完了就判断下一个序列 if(j &gt;= lg - 1) &#123; //判断是否有end结尾，如果没有就说明是无效序列 cnt = 0; break; &#125; &#125; break; &#125; &#125; if(cnt &lt;= 0) printf("None"); else &#123; for(int i = 0; i &lt; cnt; i++) &#123; cout &lt;&lt; putstr[i]; if(i != cnt - 1) cout &lt;&lt; ","; &#125; &#125; return 0;&#125; 僵尸危机传送门 思路：这题难点在于理解题意，理解了题意就很简单。 123456789101112131415161718#include&lt;cstdio&gt;int f[1000], a[1000];int main(void)&#123; int n; scanf("%d", &amp;n); f[0] = 1; a[0] = 3; int day = 0; while(a[day] &lt; n) &#123; f[day + 1] = a[day] - (f[day] % 4 ? f[day] / 4 + 1 : f[day] / 4); a[day + 1] = f[day + 1] * 3; day++; &#125; if(day &lt;= 1) printf("%d day", day + 1); //注意是day+1 else printf("%d days", day + 1); return 0;&#125; 再去明星演唱会传送门 思路：简单的dfs，然后用栈（我用的是vector来模拟栈）存储记录点座标的结构体，当到达目标座标的时候，按格式输出栈里面的所有座标，而且要分四次在四个角上使用dfs，如果角上坐了人，就输出-1，或者无法到达目标座标也输出-1，这里用flag来标志是否能到达目标座标。（由于之前刷题时，题目测试数据里面有目标座标可能也坐了人，所以要特判，此时算是到达了目标座标，不过比赛的数据我不知道有没有这种测试数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;int a[20][20], nex[4][2] = &#123;0, -1, -1, 0, 0, 1, 1, 0&#125;, n, m, ex, ey, flag = 0, book[20][20]; //a数组存储某点是否有人，next用于按照左下右上的顺序遍历，book数组用来判断是否已经走过这个点。struct node &#123; int x, y;&#125;;vector&lt;node&gt; ss;//记录已经走过的路径void dfs(int x, int y) //完全是dfs模板，&#123; if(x == ex &amp;&amp; y == ey) &#123; flag = 1; //说明从这个点可以到达目标座标 int len = ss.size(); for(int i = 0; i &lt; len; i++) &#123; printf("(%d,%d)", ss[i].x, ss[i].y); if(i != len - 1) printf("-&gt;"); &#125; printf("\n"); return ; &#125; for(int i = 0; i &lt; 4; i++) &#123; int tx = x + nex[i][0]; int ty = y + nex[i][1]; if(tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; m || book[tx][ty] || (a[tx][ty] == 1 &amp;&amp; !(tx == ex &amp;&amp; ty == ey))) continue; //这里的最后括号里面的特判是因为目标座标可能有人，也算可以到达，这是因为之前有个数据卡了我很多次。。。这个比赛的数据我不知道有没有卡。。。 book[tx][ty] = 1; node tn; tn.x = tx; tn.y = ty; ss.push_back(tn); dfs(tx, ty); ss.pop_back(); book[tx][ty] = 0; &#125;&#125;int main(void)&#123; scanf("%d %d", &amp;ex, &amp;ey); scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; int beg[4][2] = &#123;1, 1, 1, m, n, 1, n, m&#125;; for(int i = 0; i &lt; 4; i++) &#123; flag = 0; if(a[beg[i][0]][beg[i][1]] == 1) &#123; //判断角上是否有人，有人就不能走 printf("-1\n"); continue; &#125; for(int ii = 1; ii &lt;= n; ii++) &#123; for(int j = 1; j &lt;= m; j++) &#123; book[ii][j] = 0; &#125; &#125; book[beg[i][0]][beg[i][1]] = 1; node tn; tn.x = beg[i][0]; tn.y = beg[i][1]; ss.push_back(tn); dfs(beg[i][0], beg[i][1]); ss.pop_back(); book[beg[i][0]][beg[i][1]] = 0; if(flag == 0) &#123; //这个角无法到达目标座标 printf("-1\n"); &#125; &#125; return 0;&#125; 摸鱼传送门 思路：这题我是用一个结构体存储每个人的编号、随机数、对他%的人数。每当输入一个朋友关系的时候，判断谁的随机数大，然后大的那个人的 对他%的人数 减一（就是减掉他的朋友），然后把这个结构体数组按照随机数大小从小到大排序，然后根据下标计算每个人的对他%的人数，再按照编号排序，输出%他的人数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int f[200100];struct node &#123; int num, random; int bai;&#125; ss[200100];bool cmp(node a, node b)&#123; if(a.random != b.random) return a.random &lt; b.random; return a.num &lt; b.num;&#125;bool cmp1(node a, node b)&#123; return a.num &lt; b.num;&#125;int main(void)&#123; int n, k; scanf("%d %d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;ss[i].random); ss[i].num = i; ss[i].bai = 0; &#125; for(int i = 1; i &lt;= k; i++) &#123; int a, b; scanf("%d %d", &amp;a, &amp;b); if(ss[a].random &lt; ss[b].random) ss[b].bai--; else if(ss[a].random &gt; ss[b].random) ss[a].bai--; &#125; sort(ss + 1, ss + n + 1, cmp); int cnt = 0; for(int i = 2; i &lt;= n; i++) &#123; //这是重点代码，判断有几个人的随机数小于现在这个人 if(ss[i - 1].random == ss[i].random) ss[i].bai += cnt; else &#123; cnt = i - 1; ss[i].bai += cnt; &#125; &#125; /* printf("\n"); for(int i=1;i&lt;=n;i++)&#123; printf("%d",ss[i].random); if(i!=n) printf(" "); &#125; */ sort(ss + 1, ss + n + 1, cmp1); for(int i = 1; i &lt;= n; i++) &#123; printf("%d", ss[i].bai &lt; 0 ? 0 : ss[i].bai); if(i != n) printf(" "); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解]]></title>
    <url>%2Ffbf2b730%2F</url>
    <content type="text"><![CDATA[洛谷 p2812 回家链接 思路：直接用dfs搜索，需要注意的是当移动时，有的点只可以经过一次（起点和鼠标所在的点，防止走回头路），有的点则可以经过两次（一次是残血，一次是走到附近加了血之后）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;int flag = 0, n, m, a[10][10], hp = 6, min = 0x3f3f3f3f, sum = 0, book[10][10];int next[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;void dfs(int x, int y)&#123; if(hp == 0) return; //此时没血了,不能走了 if(a[x][y] == 4) &#123; //到达鼠标所在的点 hp = 6; book[x][y] = 1; &#125; if(a[x][y] == 3) &#123; //到达终点 flag = 1; min = sum &lt; min ? sum : min; return; &#125; int tx, ty; for(int i = 0; i &lt; 4; i++) &#123; tx = x + next[i][0]; ty = y + next[i][1]; if(a[tx][ty] == 2 || tx &lt; 1 || tx &gt; n || ty &lt; 1 || ty &gt; m || a[tx][ty] == 0 || (a[tx][ty] == 4 &amp;&amp; book[tx][ty] == 1) || book[tx][ty] == 2 ) continue; int t = hp; hp--; sum++; book[tx][ty]++; dfs(tx, ty); book[tx][ty]--; sum--; hp = t; &#125; return;&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; int x, y; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(2 == a[i][j]) &#123; x = i; y = j; &#125; &#125; &#125; dfs(x, y); if(flag == 1) printf("%d", min); else printf("-1"); return 0;&#125; 洛谷 p1443 马的遍历链接 思路：直接套模板。。。bfs。。。（虽然很水，但可以复习bfs模板。。。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;int n, m, startx, starty, a[401][401], book[401][401], next[8][2] = &#123;2, 1, 1, 2, -1, 2, -2, 1, -2, -1, -1, -2, 1, -2, 2, -1&#125;;bool judge(int x, int y)&#123; if(x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m) &#123; return false; &#125; return true;&#125;struct node &#123; int x; int y; int step;&#125; que[160001];int main(void)&#123; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;startx, &amp;starty); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; a[i][j] = -1; &#125; &#125; a[startx][starty] = 0; book[startx][starty] = 1; int head = 1, tail = 1; que[tail].x = startx; que[tail].y = starty; que[tail].step = 0; tail++; while(head &lt; tail) &#123; for(int i = 0; i &lt; 8; i++) &#123; int tx = que[head].x + next[i][0]; int ty = que[head].y + next[i][1]; if(book[tx][ty] == 1 || !judge(tx, ty) ) continue; que[tail].x = tx; que[tail].y = ty; a[tx][ty] = que[tail].step = que[head].step + 1; tail++; book[tx][ty] = 1; &#125; head++; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; printf("%-5d", a[i][j]); &#125; printf("\n"); &#125; return 0;&#125; 洛谷 p1892 团伙链接 思路：这是一个并查集的题目，需要注意的就是，敌人的敌人是朋友，所以在判断敌人时，要多弄一个把敌人的敌人合并为朋友的语句。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int n, m, f[1001], e[1001];int getf(int u)&#123; if(f[u] == u) return u; f[u] = getf(f[u]); return f[u];&#125;bool merge(int u, int v)&#123; int t1 = getf(u); int t2 = getf(v); if(t1 == t2) return false; f[v] = t1; return true;&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; f[i] = i; e[i] = 0; &#125; for(int i = 1; i &lt;= m; i++) &#123; char ch; int p, q; //scanf("%c %d %d",&amp;ch,&amp;p,&amp;q); cin &gt;&gt; ch &gt;&gt; p &gt;&gt; q; if(ch == 'F') &#123; merge(p, q); &#125; else if(ch == 'E') &#123; if(e[p] != 0) &#123; merge(e[p], q); &#125; else e[p] = q; if(e[q] != 0) &#123; merge(e[q], p); &#125; else e[q] = p; &#125; &#125; int sum = 0; for(int i = 1; i &lt;= n; i++) &#123; if(f[i] == i) sum++; &#125; printf("%d", sum); return 0;&#125; 洛谷 p2024食物链链接 思路：这题我没想到思路，通过看题解的思路来写代码。这题是种类并查集 的题目，通过将初始数组的大小置为n的倍数，然后将数组划分为若干个集合（1 ~ n , n+1 ~ 2n , … 每个集合里面有n个元素），第二个集合是第一个集合的天敌，第三个集合是第二个集合的天敌，第一个集合是第三个集合的天敌，然后通过将同类动物放在同一个集合里讨论，不同类动物（敌对）则在不同的集合里面讨论。当对动物进行合并时，要同时对不同的集合进行操作。当对输入的东西进行讨论是则只需要只需要对一组集合进行讨论就可以了。（种类并查集求的并非具体种类，而是关系！）参考的题解链接 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;int n, k, f[150001];int getf(int u) //找同类&#123; return f[u] == u ? u : f[u] = getf(f[u]);&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;k); for(int i = 1; i &lt;= n * 3; i++) f[i] = i; int a, x, y, sum = 0; for(; k; k--) &#123; scanf("%d %d %d", &amp;a, &amp;x, &amp;y); if(x &gt; n || y &gt; n) &#123; sum++; continue; &#125; if(a == 1) &#123; if(getf(x) == getf(y + n) || getf(x + n) == getf(y)) &#123; //当x和y时互相为天敌时，这个输入的语句为假 sum++; &#125; else &#123; //将x和y设置为同类(三个集合都要设置) f[getf(x)] = getf(y); f[getf(x + n)] = getf(y + n); f[getf(x + 2 * n)] = getf(y + 2 * n); &#125; &#125; else &#123; if(getf(x) == getf(y) || getf(x + n) == getf(y)) &#123; //判断是否是同类 sum++; &#125; else &#123; //将x和y设置为天敌关系 f[getf(x)] = getf(y + n); f[getf(x + n)] = getf(y + 2 * n); f[getf(x + 2 * n)] = getf(y); &#125; &#125; &#125; printf("%d", sum); return 0;&#125; 洛谷 p3371 【模板】单源最短路径（弱化版）链接 思路：这题如果用邻接矩阵会有三个MLE，原因是邻接矩阵数组过大（10000 X 10000），然后用了一些时间学习链式前向星。所以我最后ac的解法是Dijkstra+链式前向星 。还有就是用快读的方式减少运行时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#define Maxn 10001const int inf = 0x3f3f3f3f;int n, m, s, dis[Maxn], book[Maxn];int cnt = 1, head[Maxn] = &#123;0&#125;; //head用来记录以某个起点的第一条边，cnt用来记录edge的当前下标struct Edge &#123; int next;//（同一起点）下一条边的数组下标 int to;//边的终点 int w;//边的长度(权)&#125; edge[500001];void add(int u, int v, int w) //将以u为起点v为终点的边存储到链式前向星里面&#123; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++;&#125;int read(void) //快读&#123; char ch = getchar(); int n = 0; while(ch &lt; '0' || ch &gt; '9') ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; n = (n &lt;&lt; 1) + (n &lt;&lt; 3) + ( ch &amp; 15 ); ch = getchar(); &#125; return n;&#125;int main(void)&#123; n = read(); m = read(); s = read(); for(int i = 1; i &lt;= n; i++) dis[i] = inf; dis[s] = 0; for(; m; m--) &#123; int u, v, w; u = read(); v = read(); w = read(); add(u, v, w); &#125; int t = s, min = inf; while(!book[t]) &#123; //条件为当dis存在未确定的边里面的最小边,至于原因可以看dijkstra算法 book[t] = 1; for(int i = head[t]; i; i = edge[i].next) &#123; //从某一始点的第一条边开始遍历，松弛dis数组 if(!book[edge[i].to] &amp;&amp; dis[edge[i].to] &gt; dis[t] + edge[i].w) dis[edge[i].to] = dis[t] + edge[i].w; &#125; min = inf; for(int i = 1; i &lt;= n; i++) &#123; //查看是否所有点已经松弛完成，即所有点都确定了 if(!book[i] &amp;&amp; dis[i] &lt; min) &#123; t = i; min = dis[i]; &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; if(dis[i] != inf) printf("%d ", dis[i]); else printf("2147483647 "); &#125; return 0;&#125; 洛谷 P1462 通往奥格瑞玛的道路链接 思路：这题我写了两天（改代码和学习，我太菜了）。。。题意的交费最多的最小值就是当他（歪嘴）能到达终点时，肯定有个收费最多的点，在所有可能的路径中，收费最多的点的最小值。用dijkstra+二分来写（还要用堆优化，不然会tle。。。卡了将近一天），主要是将点权二分，然后找最短满足点权条件的最短路径，一直二分，最后找到满足条件的最小值。堆优化就是找出利用priority_queue（大佬也可以用手写最小堆）来记录dijkstra里面遍历到的点，其中要自定义一个struct cmp 来作为模板参数的第三个参数（以!cmp录入，和sort函数不同）。然后就是二分后的top（将大于top的点直接排除）要作为check函数里面部分条件的判断依据（如代码）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int MAXn = 10001; //最大的点的数目const int inf = 0x3f3f3f3f;int cnt = 1, dis[MAXn], book[MAXn] = &#123;0&#125;, n, m, b, head[MAXn], f[MAXn];struct cmp &#123; //我没试直接写个cmp函数可不可以。。。 bool operator()(int &amp;a, int &amp;b) const &#123; //因为优先出列判定为!cmp，所以反向定义实现最小值优先 return dis[a] &gt; dis[b]; &#125;&#125;;void quicksort(int *p, int left, int right) //快排。。。（tle后各种优化，连sort都换了）&#123; if(left &gt; right) return; int temp = p[left]; int l = left, r = right; while(l != r) &#123; while(p[r] &gt;= temp &amp;&amp; l &lt; r) r--; while(p[l] &lt;= temp &amp;&amp; l &lt; r) l++; if(l &lt; r) &#123; int t = p[l]; p[l] = p[r]; p[r] = t; &#125; &#125; p[left] = p[l]; p[l] = temp; quicksort(p, left, l - 1); quicksort(p, l + 1, right);&#125;int read(void)&#123; int n = 0; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; n = (n &lt;&lt; 1) + (n &lt;&lt; 3) + (ch &amp; 15); ch = getchar(); &#125; return n;&#125;struct Edge &#123; int next; int to; int w;&#125; edge[2 * 50001];void add(int u, int v, int w)&#123; edge[cnt].w = w; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt++;&#125;bool check(int top)&#123; if(top &lt; f[1] || top &lt; f[n]) return false; int t; for(int i = 1; i &lt;= n; i++) &#123; dis[i] = inf; book[i] = 0; &#125; dis[1] = 0; priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; pq; //用堆记录dis里面未松弛的点里面的最小值的点 pq.push(1); while(!pq.empty()) &#123; t = pq.top(); pq.pop(); if(book[t] || top &lt; f[t]) continue; //如果已经松弛或者当前点收费大于top时 book[t] = 1; for(int i = head[t]; i; i = edge[i].next) &#123; //边的遍历，对dis松弛. if(f[edge[i].to] &lt;= top &amp;&amp; !book[edge[i].to] &amp;&amp; dis[edge[i].to] &gt; dis[t] + edge[i].w) &#123; dis[edge[i].to] = dis[t] + edge[i].w; pq.push(edge[i].to); &#125; &#125; &#125; return dis[n] &lt;= b;&#125;int main(void)&#123; n = read(); m = read(); b = read(); int c[MAXn] = &#123;0&#125;; for(int i = 1; i &lt;= n; i++) &#123; f[i] = read(); c[i] = f[i]; &#125; int u, v, w; for(int i = 1; i &lt;= m; i++) &#123; u = read(); v = read(); w = read(); if(u == v) continue; add(u, v, w); add(v, u, w); &#125; quicksort(c, 1, n); int l = 1, r = n, mid; if(!check(c[n])) &#123; //判断是否有到达终点的路径 printf("AFK\n"); return 0; &#125; int ans = c[n]; while(l &lt;= r) &#123; //对点的费用按大小进行二分 mid = (l + r) &gt;&gt; 1; if(check(c[mid])) &#123; r = mid - 1; ans = c[mid]; &#125; else l = mid + 1; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01迷宫]]></title>
    <url>%2Fd877abb7%2F</url>
    <content type="text"><![CDATA[01迷宫 题目链接(洛谷) 这题主要是理解题目意思，我一开始以为这题描述的是求能走的最长路径，后来wa了找不出问题，看了题解才知道原来不是求最长路径，而是求从某点能到达的所有的点的总数（包括自己）。理解了题意就容易了，我用的方法是先dfs+染色，再根据输入的位置来输出结果。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;int a[1001][1001], book[1001][1001], f[1000001], n, m; //数组a保存地图，数组book记录染色情况，数组f记录某个颜色总大小int next[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;; //前进的方向int read(void) //快读&#123; char ch = getchar(); while(ch != '1' &amp;&amp; ch != '0') ch = getchar(); return ch &amp; 1;&#125;void dfs(int aa, int bb, int color) //aa和bb为位置，color为当前染色的颜色&#123; int tx, ty; for(int i = 0; i &lt; 4; i++) &#123; tx = aa + next[i][0]; ty = bb + next[i][1]; if(tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; n || book[tx][ty] || a[tx][ty] == a[aa][bb]) continue; f[color]++; book[tx][ty] = color; dfs(tx, ty, color); &#125;&#125;int main(void)&#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; a[i][j] = read(); &#125; &#125; int c = 1; //颜色 for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(!book[i][j]) &#123;//当前点未经过染色 f[c] = 1; //把当前点也记录进去 book[i][j] = c; //开始染色 dfs(i, j, c++); &#125; &#125; &#125; int x, y; for(int i = 1; i &lt;= m; i++) &#123; //读入点的坐标 scanf("%d %d", &amp;x, &amp;y); printf("%d", f[book[x][y]]); //输出当前颜色占据的总大小，即当前点能到达的所有的点的数目 if(i != m) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂和矩阵的快速幂]]></title>
    <url>%2F6b81fe2c%2F</url>
    <content type="text"><![CDATA[快速幂和矩阵的快速幂求an的值，可以一个一个乘起来，也可以转化为其他多个数想乘，例如an=an/2* an/2=an/3* an/3* an/3=…，当n的值非常大的时候，这两种求法效率明显不够高，所以就有大佬想出了快速幂的算法，快速幂算法的主要代码如下： 12345678int res=1;//res为记录结果的变量void pow(int a,int n)&#123; while(n)&#123; if(n&amp;1) res*=a; n&gt;&gt;=1; a*=a; &#125;&#125; 如果看代码无法理解（反正我直接看代码是没理解），则可以结合例子看代码： 276=201001100B(2进制)=2100B* 21000B* 21000000B=24* 28 * 264 而矩阵的快速幂算法则差不多是一样的，下面为题目贴图和代码： 方阵的阶乘 描述 给定一个N阶方阵A，输出A的M次幂对10000求余的值（M是非负整数） 输入 第一行是一个正整数N、M（1&lt;=N&lt;=50, 0&lt;=M&lt;=7.5e18），表示方阵A的阶数和要求的幂数 接下来N行，每行N个绝对值不超过10的非负整数，描述方阵A的值 输出 输出共N行，每行N个整数，表示A的M次幂所对应的方阵对10000求余数。相邻的数之间用一个空格隔开 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;int a[51][51], b[51][51]; //a为当前输入的矩阵，b为记录结果的矩阵int n;void cheng(int x[][51], int y[][51]) //x*=y(x和y为矩阵)&#123; int sum = 0, z[51][51] = &#123;0&#125;; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; for(int k = 1; k &lt;= n; k++) &#123; sum += x[i][k] * y[k][j]; &#125; z[i][j] = sum % 10000; sum = 0; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; x[i][j] = z[i][j]; &#125; &#125;&#125;void mi(int x[][51], long long int m)&#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(i == j) b[i][j] = 1; //注意记录结果的数组初始值设置 &#125; &#125; while(m) &#123; //主要代码 if(m &amp; 1) &#123; cheng(b, x); &#125; m &gt;&gt;= 1; cheng(x, x); &#125;&#125;int main(void)&#123; long long int m; scanf("%d %lld", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;a[i][j]); &#125; &#125; mi(a, m); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; printf("%d", b[i][j]); if(j != n) printf(" "); &#125; if(i != n) printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[To Fill or Not to Fill]]></title>
    <url>%2F21fcb834%2F</url>
    <content type="text"><![CDATA[题目：To Fill or Not to Fill` 题目链接 这题主要是贪心，然后就是细节了，首先，输入的数字除了N以外都要用double（不能用float，不然有大的数据会通不过），具体思路是：1.当加油站之间的距离或与终点的距离大于满油时能行驶的最大距离时，要输出最大距离。2.在加油站的一定距离以内，第一个价格比当前加油站价格低的加油站为下一个需要直接到达的加油站。3.若在加油站以内没有比当前加油站价格低的加油站，则加满油后直接去最价格相对最低的加油站。4.若当前加油站能直接到达终点，且范围内没有价格更低的加油站时，直接到达终点（即使是最后一个加油站也是如此判断） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int N, cur, minn;double Cmax, D, Davg, oil = 0.0;const double inf = 0x3f3f3f3f;struct ss &#123; double m; double p;&#125; qq[510];bool cmp(ss a, ss b)&#123; return a.p &lt; b.p;&#125;int find(void)&#123; minn = cur; double min = inf; if(qq[cur + 1].p - qq[cur].p &gt; Cmax * Davg) return -1; int i; for(i = cur + 1; qq[i].p - qq[cur].p &lt;= Cmax * Davg &amp;&amp; i &lt; N; i++) &#123; if(qq[i].m &lt; qq[cur].m) &#123; minn = i; break; &#125; &#125; if(minn == cur) &#123; for(int j = cur + 1; qq[j].p - qq[cur].p &lt;= Cmax * Davg &amp;&amp; j &lt; N; j++) &#123; if(qq[j].m &lt; min) &#123; min = qq[j].m; minn = j; &#125; &#125; return cur; &#125; else &#123; return minn; &#125;&#125;int main(void)&#123; scanf("%lf %lf %lf %d", &amp;Cmax, &amp;D, &amp;Davg, &amp;N); cur = 0; for(int i = 0; i &lt; N; i++) &#123; scanf("%lf %lf", &amp;qq[i].m, &amp;qq[i].p); &#125; qq[N].p = D; //printf("%d\n",qq[0].p); stable_sort(qq, qq + N, cmp); //printf("%d\n",qq[0].p); if(qq[0].p != 0) &#123; printf("The maximum travel distance = 0.00"); return 0; &#125; double maxm = 0.0, maxp = 0; int r; bool flag = 1; cur = 0; while(flag) &#123; r = find(); //printf("%d\n",r); //printf("--%d\n",cur); if(r == -1) &#123; maxp = qq[cur].p + Cmax * Davg; flag = 0; break; &#125; else if(r == cur) &#123; if(qq[cur].p + Cmax * Davg &gt;= D) &#123; maxm += qq[cur].m * ((D - qq[cur].p) / Davg - oil); break; &#125; maxm += (Cmax - oil) * qq[cur].m; oil = Cmax - (qq[minn].p - qq[cur].p) / Davg; cur = minn; &#125; else &#123; maxm += ((qq[r].p - qq[cur].p) / Davg - oil) * qq[cur].m; oil = 0.0; cur = r; &#125; &#125; if(flag == 0) &#123; printf("The maximum travel distance = %.2lf", maxp); &#125; else &#123; printf("%.2lf", maxm); &#125; return 0;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础——渐近记号]]></title>
    <url>%2Fa1f432c7%2F</url>
    <content type="text"><![CDATA[算法基础————渐近记号Θ(大 theta)记号 Θ(g(n)) = { f(n) : 存在正常量c1、c2和n0，使得对所有的n &gt;= n0，有 0 &lt;= c1g(n) &lt;= f(n) &lt;= c2g(n) } 注：在集合记号中，冒号意指“使得”。 O(大 O)记号 O(g(n)) = { f(n) : 存在正常量 c 和 n0，使得对所有的 n &gt;= n0，有 0 &lt;= f(n) &lt;=cg(n) } Ω(大 Omega)记号 Ω(g(n)) = { f(n) : 存在正常量 c 和 n0，使得对所有的 n &gt;= n0，有 0 &lt;= cg(n) &lt;= f(n) } o(小 o)记号 o(g(n)) = { f(n) : 对任意正常量c &gt; 0，存在常量 n0 &gt; 0，使得对所有的 n &gt;= n0，有 0 &lt;= f(n) &lt; cg(n) } o记号和O记号的定义类似。主要区别是在f(n) = O(g(n))中，界0 &lt;= f(n) &lt;=cg(n)对某个常量c &gt; 0成立。但在f(n) = o(g(n))中，界0 &lt;= f(n) &lt; cg(n)对所有常量c &gt; 0成立。 ω(小 Omega)记号 ω(g(n)) = { f(n) : 对任意正常量c &gt; 0，存在常量n0 &gt; 0，使得对所有的 n &gt;= n0，有 0 &lt;= cg(n) &lt; f(n) } 总结 记号 含义 例子 Θ(大 theta)记号 渐近紧确界 Θ(n2) = an2 + bn + c = 0(a &gt; 0) O(大 O)记号 渐近上界 Θ(n2) ⊂ O(n2) = an2 + bn + c = 0(a &gt; 0) Ω(大 Omega)记号 渐近下界 Θ(n2) ⊂ Ω(n2) = an2 + bn + c = 0(a &gt; 0) o(小 o)记号 非渐近紧确的上界 2n = o(n2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2n2 ≠ o(n2) ω(小 Omega)记号 非渐近紧确的下界 n2/2 = ω(n) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n2/2 ≠ ω(n2)]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fd87f7e0c%2F</url>
    <content type="text"><![CDATA[…测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于搭建博客的想法]]></title>
    <url>%2F3e4ccedd%2F</url>
    <content type="text"><![CDATA[​ 搭建一个属于自己的博客是我在暑假突然心血来潮的想法，至于为什么想要搭建博客，一开始主要是因为看上去很（zhuang）酷（bi），后来在搭建博客过程中搜索查看别人的博客时，发现事实上真的挺酷的。于是更加坚定了我 搭建博客 并且 一直写博客 的信念。 ​ 我对博客的认知就是，记录和分享你的知识和生活。至于以后要写什么东西，可能我会在我的博客里面写下学习遇到的难点、重点和易错点，以及偶尔会写下关于其他方面的东西。 ​ 关于如何用 gitpage+hexo 搭建博客，可以参照下面的教程链接。 ​ ​ https://thief.one/2017/03/03/Hexo搭建博客教程/ ​ https://www.jianshu.com/p/f054333ac9e6]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
